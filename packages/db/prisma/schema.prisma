generator client {
  provider        = "prisma-client-js"
  output          = "../generated/node"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "rhel-openssl-3.0.x", "linux-arm64-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

generator edge {
  provider        = "prisma-client-js"
  output          = "../generated/edge"
  previewFeatures = ["driverAdapters", "postgresqlExtensions"]
  binaryTargets   = ["native"]
}

generator zod {
  provider = "zod-prisma-types"
  output   = "../generated/zod-prisma-validators"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp", schema: "extensions"), vector]
}

model User {
  id                   String     @id
  firstName            String?
  lastName             String?
  username             String?    @unique
  primaryEmailAddress  String     @unique
  imageUrl             String?
  clerkUserProperties  Json?
  stripeCustomerId     String?    @unique
  accessType           AccessType @default(FREE)
  stripeUserProperties Json?
  dailyAIcomments      Int        @default(0)
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  profileImportRuns ProfileImportRun[]
  linkedInAccounts  LinkedInAccount[]

  UserBrowserState UserBrowserState[]
  Comments         UserComment[]
  AutoCommentRun   AutoCommentRun[]
}

model LinkedInAccount {
  id                 String   @id @default(uuid())
  user               User     @relation(fields: [userId], references: [id])
  userId             String
  email              String
  encryptedPassword  String
  active             Boolean  @default(true)
  twoFactorSecretKey String
  createdAt          DateTime @default(now())
  staticIpId         String?
  browserProfileId   String?
  location           String?
}

enum AccessType {
  FREE
  WEEKLY
  MONTHLY
  YEARLY
}

enum ImportStatus {
  NOT_STARTED
  RUNNING
  FINISHED
}

model ProfileImportRun {
  id            String       @id @default(uuid())
  userId        String
  user          User         @relation(fields: [userId], references: [id])
  urls          String[]
  status        ImportStatus @default(NOT_STARTED)
  urlsSucceeded String[]     @default([])
  urlsFailed    String[]     @default([])
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model LinkedInProfile {
  id          String @id @default(uuid()) // Unique identifier
  linkedinUrl String // Required
  fullName    String // Required
  headline    String // Required
  urn         String @unique // Required, globally unique
  profilePic  String // Required

  firstName               String?
  lastName                String?
  connections             Int?
  followers               Int?
  email                   String?
  mobileNumber            String?
  jobTitle                String?
  companyName             String?
  companyIndustry         String?
  companyWebsite          String?
  companyLinkedin         String?
  companyFoundedIn        Int?
  companySize             String?
  currentJobDuration      String?
  currentJobDurationInYrs Float?
  topSkillsByEndorsements String?
  addressCountryOnly      String?
  addressWithCountry      String?
  addressWithoutCountry   String?
  profilePicHighQuality   String?
  about                   String?
  publicIdentifier        String?
  openConnection          Boolean?

  // Nested/complex structures stored as JSON
  experiences             Json?
  updates                 Json?
  skills                  Json?
  profilePicAllDimensions Json?
  educations              Json?
  licenseAndCertificates  Json?
  honorsAndAwards         Json?
  languages               Json?
  volunteerAndAwards      Json?
  verifications           Json?
  promos                  Json?
  highlights              Json?
  projects                Json?
  publications            Json?
  patents                 Json?
  courses                 Json?
  testScores              Json?
  organizations           Json?
  volunteerCauses         Json?
  interests               Json?
  recommendations         Json?

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  targetProfiles TargetProfile[]
}

model UserComment {
  id               String          @id
  urn              String
  postContentHtml  String?
  hash             String?
  autoCommentRunId String?
  comment          String
  userId           String
  isDuplicate      Boolean         @default(false)
  isAutoCommented  Boolean         @default(true)
  user             User            @relation(fields: [userId], references: [id])
  autoCommentRun   AutoCommentRun? @relation(fields: [autoCommentRunId], references: [id])

  @@index([hash])
}

model AutoCommentRun {
  id        String        @id
  userId    String
  user      User          @relation(fields: [userId], references: [id])
  startedAt DateTime      @default(now())
  endedAt   DateTime?
  error     String?
  status    String
  comments  UserComment[]
}

model UserBrowserState {
  userId String @id
  state  String
  user   User   @relation(fields: [userId], references: [id])
}

model TargetList {
  id             String          @id
  userId         String
  name           String
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  targetProfiles TargetProfile[]
}

model TargetProfile {
  id         String          @id
  listId     String
  userId     String
  profileUrn String          @unique
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  list       TargetList      @relation(fields: [listId], references: [id])
  profile    LinkedInProfile @relation(fields: [profileUrn], references: [urn])

  @@unique([listId, profileUrn])
}

model BlacklistedProfile {
  id         String   @id
  userId     String
  profileUrn String
  createdAt  DateTime @default(now())

  @@unique([userId, profileUrn])
}

model ExtensionDeploymentMeta {
  id        String   @id
  createdAt DateTime @default(now())
}
