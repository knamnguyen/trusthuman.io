 generator client {
  provider        = "prisma-client-js"
  output          = "../generated/node"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "rhel-openssl-3.0.x", "linux-arm64-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

generator edge {
  provider        = "prisma-client-js"
  output          = "../generated/edge"
  previewFeatures = ["driverAdapters", "postgresqlExtensions"]
  binaryTargets   = ["native"]
}

generator zod {
  provider = "zod-prisma-types"
  output   = "../generated/zod-prisma-validators"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp", schema: "extensions"), vector]
}

model User {
  id                   String     @id
  firstName            String?
  lastName             String?
  username             String?    @unique
  primaryEmailAddress  String     @unique
  imageUrl             String?
  clerkUserProperties  Json?
  stripeCustomerId     String?    @unique
  accessType           AccessType @default(FREE)
  stripeUserProperties Json?
  dailyAIcomments      Int        @default(0)
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  profileImportRuns ProfileImportRun[]
  linkedInAccounts  LinkedInAccount[]

  UserBrowserState        UserBrowserState[]
  Comments                UserComment[]
  AutoCommentRun          AutoCommentRun[]
  CommentStyle            CommentStyle[]
  AutoCommentConfig       AutoCommentConfig[]
  BlacklistedProfile      BlacklistedProfile[]
  linkedInPostPreviews    LinkedInPostPreview[]
  commentAnalyses         CommentAnalysis[]
  organizationMemberships OrganizationMember[]
}

// ============================================================================
// ORGANIZATION (Clerk-synced)
// ============================================================================

model Organization {
  id               String   @id // Clerk organization ID
  name             String
  stripeCustomerId String?  @unique
  purchasedSlots   Int      @default(1)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  members          OrganizationMember[]
  linkedInAccounts LinkedInAccount[]
}

model OrganizationMember {
  id       String   @id @default(uuid())
  orgId    String
  userId   String
  role     String // "admin" | "member"
  joinedAt DateTime @default(now())

  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([userId])
}

model LinkedInAccount {
  id                 String                @id @default(uuid())
  user               User                  @relation(fields: [userId], references: [id])
  userId             String
  email              String                @unique
  status             LinkedInAccountStatus
  createdAt          DateTime              @default(now())
  staticIpId         String?
  browserProfileId   String
  location           String
  name               String?
  isRunning          Boolean               @default(false)

  // Organization-based fields (new multi-tenant flow)
  organizationId     String?
  profileUrl         String?
  profileSlug        String?               @unique // Globally unique - one LinkedIn per system
  registrationStatus String?               // "registered" | "connected" | null

  org                Organization?         @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  AutoCommentConfig  AutoCommentConfig[]
  BlacklistedProfile BlacklistedProfile[]
  AutoCommentRun     AutoCommentRun[]
  BrowserInstance    BrowserInstance[]
  userComments       UserComment[]
}

enum LinkedInAccountStatus {
  ACTIVE
  CONNECTING
  SUSPENDED
}

enum AccessType {
  FREE
  WEEKLY
  MONTHLY
  YEARLY
}

enum ImportStatus {
  NOT_STARTED
  RUNNING
  FINISHED
}

model ProfileImportRun {
  id            String       @id @default(uuid())
  userId        String
  user          User         @relation(fields: [userId], references: [id])
  urls          String[]
  status        ImportStatus @default(NOT_STARTED)
  urlsSucceeded String[]     @default([])
  urlsFailed    String[]     @default([])
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model LinkedInProfile {
  id          String @id @default(uuid()) // Unique identifier
  linkedinUrl String // Required
  fullName    String // Required
  headline    String // Required
  urn         String @unique // Required, globally unique
  profilePic  String // Required

  firstName               String?
  lastName                String?
  connections             Int?
  followers               Int?
  email                   String?
  mobileNumber            String?
  jobTitle                String?
  companyName             String?
  companyIndustry         String?
  companyWebsite          String?
  companyLinkedin         String?
  companyFoundedIn        Int?
  companySize             String?
  currentJobDuration      String?
  currentJobDurationInYrs Float?
  topSkillsByEndorsements String?
  addressCountryOnly      String?
  addressWithCountry      String?
  addressWithoutCountry   String?
  profilePicHighQuality   String?
  about                   String?
  publicIdentifier        String?
  openConnection          Boolean?

  // Nested/complex structures stored as JSON
  experiences             Json?
  updates                 Json?
  skills                  Json?
  profilePicAllDimensions Json?
  educations              Json?
  licenseAndCertificates  Json?
  honorsAndAwards         Json?
  languages               Json?
  volunteerAndAwards      Json?
  verifications           Json?
  promos                  Json?
  highlights              Json?
  projects                Json?
  publications            Json?
  patents                 Json?
  courses                 Json?
  testScores              Json?
  organizations           Json?
  volunteerCauses         Json?
  interests               Json?
  recommendations         Json?

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  targetProfiles TargetProfile[]
}

model UserComment {
  id               String           @id
  urn              String
  postContentHtml  String?
  hash             String?
  autoCommentRunId String?
  comment          String
  userId           String?
  accountId        String?
  commentedAt      DateTime?
  isDuplicate      Boolean          @default(false)
  isAutoCommented  Boolean          @default(true)
  user             User?            @relation(fields: [userId], references: [id])
  autoCommentRun   AutoCommentRun?  @relation(fields: [autoCommentRunId], references: [id])
  account          LinkedInAccount? @relation(fields: [accountId], references: [id])

  @@index([hash])
  @@index([urn])
  @@index([commentedAt])
}

model AutoCommentRun {
  id        String        @id
  userId    String
  accountId String
  liveUrl   String
  startedAt DateTime      @default(now())
  endedAt   DateTime?
  error     String?
  status    String
  comments  UserComment[]

  user    User            @relation(fields: [userId], references: [id])
  account LinkedInAccount @relation(fields: [accountId], references: [id])
}

model UserBrowserState {
  userId String @id
  state  String
  user   User   @relation(fields: [userId], references: [id])
}

model TargetList {
  id             String          @id
  userId         String
  name           String
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  targetProfiles TargetProfile[]
}

model TargetProfile {
  id         String          @id
  listId     String
  userId     String
  profileUrn String          @unique
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
  list       TargetList      @relation(fields: [listId], references: [id])
  profile    LinkedInProfile @relation(fields: [profileUrn], references: [urn])

  @@unique([listId, profileUrn])
}

model BlacklistedProfile {
  id         String   @id
  accountId  String
  userId     String
  profileUrn String
  createdAt  DateTime @default(now())

  user    User            @relation(fields: [userId], references: [id])
  account LinkedInAccount @relation(fields: [accountId], references: [id])

  @@unique([accountId, profileUrn])
}

model ExtensionDeploymentMeta {
  id        String   @id
  createdAt DateTime @default(now())
}

model CommentStyle {
  id        String   @id
  userId    String
  name      String
  prompt    String
  createdAt DateTime @default(now())

  user              User                @relation(fields: [userId], references: [id])
  AutoCommentConfig AutoCommentConfig[]
}

model AutoCommentConfig {
  accountId                   String  @id
  userId                      String
  scrollDuration              Int
  commentDelay                Int
  maxPosts                    Int
  duplicateWindow             Int
  finishListModeEnabled       Boolean
  commentAsCompanyEnabled     Boolean
  timeFilterEnabled           Boolean
  minPostAge                  Int?
  manualApproveEnabled        Boolean
  authenticityBoostEnabled    Boolean
  targetListId                String?
  defaultCommentStyle         String?
  // commentStyleId is custom style id
  // defaultCommentStyle is from ready made prompts
  commentStyleId              String?
  commentProfileName          String?
  languageAwareEnabled        Boolean
  blacklistEnabled            Boolean
  skipPromotedPostsEnabled    Boolean
  skipFriendActivitiesEnabled Boolean
  skipCompanyPagesEnabled     Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  commentStyle    CommentStyle?   @relation(fields: [commentStyleId], references: [id], onDelete: SetNull)
}

enum BrowserInstanceStatus {
  INITIALIZING
  RUNNING
  STOPPED
  ERROR
}

model BrowserInstance {
  id                    String                @id
  hyperbrowserSessionId String                @unique
  accountId             String
  status                BrowserInstanceStatus
  createdAt             DateTime              @default(now())

  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id])
}

model LinkedInPostPreview {
  id          String   @id @default(uuid())
  userId      String
  s3Key       String
  s3Url       String
  contentJson Json
  contentText String   @db.Text
  title       String?
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model CommentAnalysis {
  id              String   @id @default(uuid())
  userId          String

  // Comment metadata
  commentUrl      String   @db.Text
  commentText     String   @db.Text
  authorName      String
  authorHeadline  String?
  authorProfileUrl String?
  avatarS3Key     String?  // Stored in S3 to avoid LinkedIn URL expiration
  avatarS3Url     String?  // Public S3 URL

  // Analysis results (stored as JSON for flexibility)
  analysisJson    Json     // Full AI detector output
  overallScore    Float    // Original percentage (0-100)
  aiScore         Float    // AI percentage (0-100)

  // Metadata
  isPublic        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}
