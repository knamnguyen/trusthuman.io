generator client {
  provider        = "prisma-client-js"
  output          = "../generated/node"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "rhel-openssl-3.0.x", "linux-arm64-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

generator edge {
  provider        = "prisma-client-js"
  output          = "../generated/edge"
  previewFeatures = ["driverAdapters", "postgresqlExtensions"]
  binaryTargets   = ["native"]
}

generator zod {
  provider = "zod-prisma-types"
  output   = "../generated/zod-prisma-validators"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [uuid_ossp(map: "uuid-ossp"), vector]
}

model User {
  id                   String     @id
  firstName            String?
  lastName             String?
  username             String?    @unique
  primaryEmailAddress  String     @unique
  imageUrl             String?
  clerkUserProperties  Json?
  stripeCustomerId     String?    @unique
  accessType           AccessType @default(FREE)
  stripeUserProperties Json?
  dailyAIcomments      Int        @default(0)
  createdAt            DateTime   @default(now())
  updatedAt            DateTime   @updatedAt

  profileImportRuns ProfileImportRun[]
  linkedInAccounts  LinkedInAccount[]

  UserBrowserState        UserBrowserState[]
  Comments                UserComment[]
  AutoCommentRun          AutoCommentRun[]
  CommentStyle            CommentStyle[]
  AutoCommentConfig       AutoCommentConfig[]
  BlacklistedProfile      BlacklistedProfile[]
  linkedInPostPreviews    LinkedInPostPreview[]
  commentAnalyses         CommentAnalysis[]
  organizationMemberships OrganizationMember[]
}

// ============================================================================
// ORGANIZATION (Clerk-synced)
// ============================================================================

model Organization {
  id               String   @id // Clerk organization ID
  name             String
  stripeCustomerId String?  @unique
  purchasedSlots   Int      @default(1)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  members          OrganizationMember[]
  linkedInAccounts LinkedInAccount[]
}

model OrganizationMember {
  id       String   @id @default(uuid())
  orgId    String
  userId   String
  role     String // "admin" | "member"
  joinedAt DateTime @default(now())

  org               Organization     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  linkedInAccount   LinkedInAccount? @relation(fields: [linkedInAccountId], references: [id])
  linkedInAccountId String?

  @@unique([orgId, userId])
  @@index([userId])
}

model LinkedInAccount {
  id                 String                @id @default(uuid())
  owner              User                  @relation(fields: [ownerId], references: [id])
  ownerId            String
  email              String                @unique
  status             LinkedInAccountStatus
  createdAt          DateTime              @default(now())
  staticIpId         String?
  browserProfileId   String
  location           String
  name               String?
  autocommentEnabled Boolean               @default(false)
  runDailyAt         String?
  isRunning          Boolean               @default(false)
  accessType         AccessType            @default(FREE)

  // Organization-based fields (new multi-tenant flow)
  organizationId     String?
  profileUrl         String?
  profileSlug        String? @unique // Globally unique - one LinkedIn per system
  registrationStatus String? // "registered" | "connected" | null

  org                     Organization?        @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  AutoCommentConfig       AutoCommentConfig[]
  BlacklistedProfile      BlacklistedProfile[]
  AutoCommentRun          AutoCommentRun[]
  BrowserInstance         BrowserInstance[]
  userComments            UserComment[]
  browserJobs             BrowserJob[]
  targetLists             TargetList[]
  targetProfiles          TargetProfile[]
  organizationMemberships OrganizationMember[]
  buildTargetListJobs     BuildTargetListJob[]
}

enum LinkedInAccountStatus {
  ACTIVE
  CONNECTING
  SUSPENDED
}

enum AccessType {
  FREE
  WEEKLY
  MONTHLY
  YEARLY
}

enum ImportStatus {
  NOT_STARTED
  RUNNING
  FINISHED
}

model ProfileImportRun {
  id            String       @id @default(uuid())
  userId        String
  user          User         @relation(fields: [userId], references: [id])
  urls          String[]
  status        ImportStatus @default(NOT_STARTED)
  urlsSucceeded String[]     @default([])
  urlsFailed    String[]     @default([])
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model LinkedInProfile {
  id          String @id @default(uuid()) // Unique identifier
  linkedinUrl String // Required
  fullName    String // Required
  headline    String // Required
  urn         String @unique // Required, globally unique (maps to "id" from new API)
  profilePic  String // Required

  firstName               String?
  lastName                String?
  connections             Int?
  followers               Int?
  email                   String?
  mobileNumber            String?
  jobTitle                String?
  companyName             String?
  companyIndustry         String?
  companyWebsite          String?
  companyLinkedin         String?
  companyFoundedIn        Int?
  companySize             String?
  currentJobDuration      String?
  currentJobDurationInYrs Float?
  topSkillsByEndorsements String?
  addressCountryOnly      String?
  addressWithCountry      String?
  addressWithoutCountry   String?
  profilePicHighQuality   String?
  about                   String?
  publicIdentifier        String?
  openConnection          Boolean?

  // Nested/complex structures stored as JSON (old API format)
  experiences             Json?
  updates                 Json?
  skills                  Json?
  profilePicAllDimensions Json?
  educations              Json?
  licenseAndCertificates  Json?
  honorsAndAwards         Json?
  languages               Json?
  volunteerAndAwards      Json?
  verifications           Json?
  promos                  Json?
  highlights              Json?
  projects                Json?
  publications            Json?
  patents                 Json?
  courses                 Json?
  testScores              Json?
  organizations           Json?
  volunteerCauses         Json?
  interests               Json?
  recommendations         Json?

  // ============================================================================
  // NEW API FIELDS (LpVuK3Zozwuipa5bp actor)
  // ============================================================================

  // Additional identifiers
  objectUrn String? // Numeric URN (e.g., "251749025")

  // Profile status flags
  openToWork   Boolean?
  hiring       Boolean?
  premium      Boolean?
  influencer   Boolean?
  memorialized Boolean?
  verified     Boolean?

  // Rich location data
  location Json? // { linkedinText, countryCode, parsed: { city, state, country, ... } }

  // Profile pictures (structured)
  profilePictureUrl   String? // Best URL from profilePicture
  coverPictureUrl     String? // Best URL from coverPicture
  profilePictureSizes Json? // Full sizes array with expiration
  coverPictureSizes   Json? // Full sizes array with expiration

  // New arrays
  websites        Json? // String array of websites
  currentPosition Json? // Array of current positions with company info
  profileActions  Json? // Array of profile action buttons
  moreProfiles    Json? // Related/suggested profiles array

  // New structured arrays (different format from old API)
  experience              Json? // New experience array with logos
  education               Json? // New education array with logos
  certifications          Json?
  volunteering            Json?
  receivedRecommendations Json?
  causes                  Json?
  featured                Json?
  services                Json?

  // Additional metadata
  topSkills        String? // Different from topSkillsByEndorsements
  connectionsCount Int? // Explicit connections count
  followerCount    Int? // Explicit follower count
  registeredAt     DateTime? // When user registered on LinkedIn

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  targetProfiles TargetProfile[]

  @@index([linkedinUrl])
}

model UserComment {
  id               String           @id
  postUrn          String
  postContentHtml  String?
  hash             String?
  autoCommentRunId String?
  autoCommentError String?
  comment          String
  urns             String[]
  // TODO: make this field required, in the new version of the app
  // every user is ensured to have a linked in account 
  userId           String?
  // TODO: make this field required
  accountId        String?
  commentedAt      DateTime?
  isDuplicate      Boolean          @default(false)
  isAutoCommented  Boolean          @default(true)
  user             User?            @relation(fields: [userId], references: [id])
  autoCommentRun   AutoCommentRun?  @relation(fields: [autoCommentRunId], references: [id])
  schedulePostAt   DateTime?
  account          LinkedInAccount? @relation(fields: [accountId], references: [id])

  @@index([hash])
  @@index([postUrn])
  @@index([commentedAt])
  @@index([urns], type: Gin)
}

model AutoCommentRun {
  id          String        @id
  accountId   String
  liveUrl     String
  startedAt   DateTime?
  endedAt     DateTime?
  scheduledAt DateTime
  error       String?
  status      String
  comments    UserComment[]
  hitlMode    Boolean       @default(false)

  account LinkedInAccount @relation(fields: [accountId], references: [id])
  user    User?           @relation(fields: [userId], references: [id])
  userId  String?
}

model UserBrowserState {
  userId String @id
  state  String
  user   User   @relation(fields: [userId], references: [id])
}

enum TargetListStatus {
  BUILDING
  COMPLETED
}

model TargetList {
  id             String           @id
  accountId      String
  name           String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  status         TargetListStatus
  targetProfiles TargetProfile[]

  linkedInAccount     LinkedInAccount      @relation(fields: [accountId], references: [id])
  buildTargetListJobs BuildTargetListJob[]
}

model TargetProfile {
  id          String           @id
  listId      String
  accountId   String
  linkedinUrl String // What user provided (raw URL)
  profileUrn  String? // Filled after profile is scraped
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  list        TargetList       @relation(fields: [listId], references: [id])
  profile     LinkedInProfile? @relation(fields: [profileUrn], references: [urn])
  account     LinkedInAccount  @relation(fields: [accountId], references: [id])

  @@unique([listId, linkedinUrl]) // Prevent duplicate URLs per list
}

model BlacklistedProfile {
  id         String   @id
  accountId  String
  profileUrn String
  createdAt  DateTime @default(now())

  account LinkedInAccount @relation(fields: [accountId], references: [id])
  user    User?           @relation(fields: [userId], references: [id])
  userId  String?

  @@unique([accountId, profileUrn])
}

model ExtensionDeploymentMeta {
  id        String   @id
  createdAt DateTime @default(now())
}

model CommentStyle {
  id        String   @id
  userId    String
  name      String
  prompt    String
  createdAt DateTime @default(now())

  user              User                @relation(fields: [userId], references: [id])
  AutoCommentConfig AutoCommentConfig[]
}

model AutoCommentConfig {
  accountId                   String  @id
  userId                      String
  scrollDuration              Int
  commentDelay                Int
  maxPosts                    Int
  duplicateWindow             Int
  finishListModeEnabled       Boolean
  commentAsCompanyEnabled     Boolean
  timeFilterEnabled           Boolean
  minPostAge                  Int?
  manualApproveEnabled        Boolean
  authenticityBoostEnabled    Boolean
  targetListId                String?
  defaultCommentStyle         String?
  // commentStyleId is custom style id
  // defaultCommentStyle is from ready made prompts
  commentStyleId              String?
  commentProfileName          String?
  languageAwareEnabled        Boolean
  blacklistEnabled            Boolean
  skipPromotedPostsEnabled    Boolean
  skipFriendActivitiesEnabled Boolean
  skipCompanyPagesEnabled     Boolean
  hitlMode                    Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  commentStyle    CommentStyle?   @relation(fields: [commentStyleId], references: [id], onDelete: SetNull)
}

enum BrowserInstanceStatus {
  INITIALIZING
  RUNNING
  STOPPED
  ERROR
}

model BrowserInstance {
  id                    String                @id
  hyperbrowserSessionId String                @unique
  accountId             String
  status                BrowserInstanceStatus
  createdAt             DateTime              @default(now())

  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id])
}

model LinkedInPostPreview {
  id          String   @id @default(uuid())
  userId      String
  s3Key       String
  s3Url       String
  contentJson Json
  contentText String   @db.Text
  title       String?
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

enum BrowserJobStatus {
  QUEUED
  RUNNING
  TERMINATED
  COMPLETED
  FAILED
}

model BrowserJob {
  id              String           @id
  status          BrowserJobStatus
  accountId       String
  error           String?
  output          String?
  createdAt       DateTime         @default(now())
  startAt         DateTime
  completedAt     DateTime?
  lastRunAt       DateTime?
  linkedInAccount LinkedInAccount  @relation(fields: [accountId], references: [id])

  @@index([status])
}

model CommentAnalysis {
  id     String @id @default(uuid())
  userId String

  // Comment metadata
  commentUrl       String  @db.Text
  commentText      String  @db.Text
  authorName       String
  authorHeadline   String?
  authorProfileUrl String?
  avatarS3Key      String? // Stored in S3 to avoid LinkedIn URL expiration
  avatarS3Url      String? // Public S3 URL

  // Analysis results (stored as JSON for flexibility)
  analysisJson Json // Full AI detector output
  overallScore Float // Original percentage (0-100)
  aiScore      Float // AI percentage (0-100)

  // Metadata
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
}

model BuildTargetListJob {
  id          String                   @id
  accountId   String
  workflowId  String
  listId      String                   @unique
  status      BuildTargetListJobStatus
  error       String?
  createdAt   DateTime                 @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id])
  targetList      TargetList      @relation(fields: [listId], references: [id])

  @@index([status])
}

enum BuildTargetListJobStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
}
