model LinkedInAccount {
  id               String                 @id @default(uuid())
  ownerId          String?
  organizationId   String?
  status           LinkedInAccountStatus?
  createdAt        DateTime               @default(now())
  staticIpId       String?
  browserProfileId String
  browserLocation  String?

  profileUrl  String? @unique
  //for checking dupliate - easier than using just profileUrl
  profileSlug String? @unique
  profileUrn  String? @unique


  autocommentEnabled Boolean    @default(false)
  runDailyAt         String?
  isRunning          Boolean    @default(false)
  accessType         AccessType @default(FREE)

  //resets count daily - but still can get from history of comments
  dailyAIcomments    Int @default(0)

  //delete
  registrationStatus String?
  name               String?
  email              String?

  owner User?        @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  org   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  //new settings (1:1)
  CommentGenerateSetting CommentGenerateSetting?
  PostLoadSetting        PostLoadSetting?
  CommentStyle           CommentStyle[]

  //existing
  targetLists TargetList[]

  // delete later since redundant - each account already one to many relations with targetlists
  targetProfiles TargetProfile[]

  //existing relations
  AutoCommentConfig       AutoCommentConfig[]
  BlacklistedProfile      BlacklistedProfile[]
  AutoCommentRun          AutoCommentRun[]
  BrowserInstance         BrowserInstance[]
  comments                Comment[]
  browserJobs             BrowserJob[]
  organizationMemberships OrganizationMember[]
  buildTargetListJobs     BuildTargetListJob[]

  @@index([organizationId])
  @@index([ownerId])
}

enum LinkedInAccountStatus {
  REGISTERED
  CONNECTING
  CONNECTED
}
