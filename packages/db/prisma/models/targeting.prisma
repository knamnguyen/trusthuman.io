model TargetList {
  id             String           @id
  accountId      String
  name           String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  status         TargetListStatus
  targetProfiles TargetProfile[]

  linkedInAccount     LinkedInAccount      @relation(fields: [accountId], references: [id])
  PostLoadSetting     PostLoadSetting? //optional 1:1 - this list may be selected in PostLoadSetting
  buildTargetListJobs BuildTargetListJob[]
}

enum TargetListStatus {
  BUILDING
  COMPLETED
}

model TargetProfile {
  id        String @id
  listId    String
  accountId String

  //get url first to store - scrape profile in linkedinprofile first (or look up) and backfill to urn
  linkedinUrl String
  profileUrn  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  list TargetList @relation(fields: [listId], references: [id])

  profile LinkedInProfile? @relation(fields: [profileUrn], references: [urn])
  account LinkedInAccount  @relation(fields: [accountId], references: [id])

  @@unique([listId, linkedinUrl])
}

//ignore for chrome extension for now
model BlacklistedProfile {
  id         String   @id
  accountId  String
  profileUrn String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  account LinkedInAccount @relation(fields: [accountId], references: [id])

  @@unique([accountId, profileUrn])
}

model BuildTargetListJob {
  id          String                   @id
  accountId   String
  workflowId  String
  listId      String                   @unique
  status      BuildTargetListJobStatus
  error       String?
  createdAt   DateTime                 @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id])
  targetList      TargetList      @relation(fields: [listId], references: [id])

  @@index([status])
}

enum BuildTargetListJobStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
}
