model TargetList {
  id        String           @id
  accountId String
  name      String
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  status    TargetListStatus

  linkedInAccount       LinkedInAccount      @relation(fields: [accountId], references: [id])
  targetListInSettings  PostLoadSetting[]    @relation("targetList")
  blacklistedInSettings PostLoadSetting[]    @relation("blacklist")
  buildTargetListJobs   BuildTargetListJob[]
  targetListProfiles    TargetListProfile[]

  @@index([accountId]) // For findListsWithProfileStatus query
}

enum TargetListStatus {
  BUILDING
  COMPLETED
}

model TargetListProfile {
  id        String @id
  listId    String
  profileId String
  accountId String

  list    TargetList      @relation(fields: [listId], references: [id])
  profile TargetProfile   @relation(fields: [profileId], references: [id])
  account LinkedInAccount @relation(fields: [accountId], references: [id])

  @@unique([listId, profileId, accountId])
}

model TargetProfile {
  id        String @id
  accountId String

  //get url first to store - scrape profile in linkedinprofile first (or look up) and backfill to urn
  linkedinUrl String  @unique
  profileUrn  String?

  // Profile data scraped from LinkedIn page for quick display
  name        String?
  profileSlug String?
  headline    String?
  photoUrl    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // profileUrn stored as plain string - query LinkedInProfile by urn when needed
  account            LinkedInAccount     @relation(fields: [accountId], references: [id])
  targetListProfiles TargetListProfile[]

  @@index([accountId, linkedinUrl]) // For findListsWithProfileStatus query
}

//ignore for chrome extension for now
model BlacklistedProfile {
  id         String   @id
  accountId  String
  profileUrn String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  account LinkedInAccount @relation(fields: [accountId], references: [id])

  @@unique([accountId, profileUrn])
}

model BuildTargetListJob {
  id          String                   @id
  accountId   String
  workflowId  String
  listId      String                   @unique
  status      BuildTargetListJobStatus
  error       String?
  createdAt   DateTime                 @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  linkedInAccount LinkedInAccount @relation(fields: [accountId], references: [id])
  targetList      TargetList      @relation(fields: [listId], references: [id])

  @@index([status])
}

enum BuildTargetListJobStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
}
