---
description: Global engineering best practices
globs:
alwaysApply: true
---

# Global Engineering Best Practices

These guidelines apply across projects. Use them alongside any repository-specific conventions captured in context files.

## TypeScript Fundamentals

- Write code and documentation in English and favor explicit types for variables, parameters, and return values.
- Avoid `any`; build domain-specific types and interfaces to preserve intent.
- Document public APIs with JSDoc after the implementation is stable, including concise examples.
- Keep functions focused on a single responsibility and avoid unnecessary blank lines in their bodies.
- Default to arrow functions; reserve the `function` keyword for exports (e.g., React components) where naming aids clarity.
- Prefer one export per file to keep module boundaries clean.
- Name functions with verbs (`getUser`, `isEnabled`, `canSubmit`) so call sites read naturally.

## Naming and Data Practices

- Use PascalCase for classes and types, camelCase for variables and functions, kebab-case for file and directory names, and UPPER_SNAKE_CASE for constants and environment variables.
- Extract magic numbers and strings into named constants; mark immutable collections with `as const` or `readonly`.
- Favor object-shaped parameters and return values when functions accept or return multiple pieces of data—keeps call sites descriptive and future-proof.
- Treat data as immutable. Use object spreads or helper utilities rather than mutating shared references.

## Functions, Classes, and Abstraction

- Limit nesting by returning early or extracting helper utilities.
- Use higher-order helpers (`map`, `filter`, `reduce`) to keep iteration declarative.
- Prefer composition over inheritance and define interfaces to capture contracts.
- Keep classes small (fewer than ten public members) and below ~200 logical instructions.
- Adopt factory or plugin patterns when object creation or behavior needs to vary cleanly.

## Styling and Tailwind

- Import Tailwind via `@import "tailwindcss"` and reference shared configuration with `@config` where needed.
- Favor flexbox layouts and the `gap` property over ad-hoc margin “bumps” for consistent spacing.
- Avoid placing layout styles inside reusable components; let callers provide container classes.
- For CSS variable arbitrary values, use parentheses syntax (e.g., `bg-(--brand-color)`).
- Ensure hover interactions remain accessible; confirm they degrade gracefully on non-hover devices.

## Third-Party Integration Discipline

- Validate API contracts before coding—review docs, inspect sample responses, and log real payloads.
- Capture TypeScript types from actual data instead of assumptions about optional fields.
- Treat each external service as the source of truth for its domain. Store foreign identifiers locally and re-fetch canonical information when needed.
- Integrate progressively: define types, parse responses, then harden with production traffic and logging.

## React, Next.js, and Component Architecture

- Create components for reusable or conceptually distinct UI blocks; move shared logic into custom hooks.
- Avoid unnecessary wrappers—use fragments instead of extra `div`s when grouping children.
- Distinguish server and client responsibilities. Add `"use client"` only when hooks or browser APIs are required, and avoid forcing server behavior with `"use server"`.
- Prefer controlled components when state must be shared; track selected entities by ID rather than duplicating objects.
- Use `useMemo` for expensive calculations and `useCallback` for functions passed to memoized children.
- Keep `useEffect` focused on a single concern. Favor React Query (or similar) for data fetching, caching, and refetching.
- Persist shareable UI state (filters, pagination) in the URL when it improves navigation or collaboration.
- Handle loading and error states explicitly; wrap async UI in suspense boundaries with meaningful fallbacks.

## Performance and Optimization

- Split bundles with dynamic imports or `React.lazy` to avoid shipping unused code.
- Provide stable `key` props in list rendering to minimize re-renders.
- Implement caching layers thoughtfully and invalidate data after mutations.
- Optimize media assets (responsive images, lazy loading) and debounce high-frequency updates.
- Monitor bundle size and address regressions promptly with tooling or code splitting.

## Security and Reliability

- Keep secrets out of the client. Use environment variables and server-side storage for sensitive configuration.
- Sanitize and validate all inbound data; employ CSRF protection where relevant.
- Enforce clear authentication and authorization checks; log security-relevant events with context.
- Rate-limit entry points vulnerable to abuse and monitor for anomalies.
- Use error boundaries for UI resilience and capture errors with structured logging or observability tooling.

## Testing and Quality

- Align testing scope with risk. Confirm with stakeholders when additional tests are warranted.
- Follow Red-Green-Refactor: write a failing test, implement the minimal fix, then refactor.
- Structure tests with Arrange-Act-Assert and keep them isolated from global state.
- Mock external services judiciously; prefer integration tests for critical flows and E2E coverage for primary user journeys.
- When skipping tests, document residual risks or manual verification steps.

## Implementation Discipline

- Estimate effort before starting significant work and reassess if scope grows.
- If abandoning an approach, harvest reusable code, document lessons learned, and clean up artifacts.
- Time-box explorations for experimental ideas and require explicit architectural validation for high-effort changes.
- Keep documentation current—update references, capture gotchas, and link to canonical resources.
