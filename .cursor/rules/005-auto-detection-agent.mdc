---
description: Auto-detects feature requests, questions, and conversation intent to automatically trigger appropriate RIPER-5 modes and workflows. Essential for making spec-driven development seamless - users just describe what they want without needing to know commands. Applies when conversation starts or when user describes a task/feature/bug.
globs:
alwaysApply: true
---

# Auto-Detection and Smart Mode Transitions

## Critical Auto-Detection Rules

### 1. Conversation Start Behavior

**On every NEW conversation (no prior context):**

1. **Check for context file existence**:
   - If `.cursor/context/all-context.md` is MISSING or EMPTY:
     - Auto-suggest: "I notice this project doesn't have a context file yet. Should I run `@generate-context.md` to scan your codebase? (Recommended for existing projects)"
     - Wait for user confirmation before scanning
2. **Auto-enter RESEARCH mode** by default:
   - Declare: `[MODE: RESEARCH]`
   - Begin understanding the request
   - Do NOT start coding or planning yet

### 2. Feature Request Auto-Detection

**Detect feature requests when user says:**

- "I want to build/create/add/implement..."
- "Can you build/create/add/implement..."
- "Let's build/create/add/implement..."
- "Build/Create/Add/Implement [something]"
- "New feature: [description]"
- "I need [feature description]"

**Auto-trigger plan generation when:**

- Request is NON-TRIVIAL (more than simple config/text changes)
- After completing RESEARCH mode
- Before entering INNOVATE mode

**Auto-response pattern:**

```
[MODE: RESEARCH]

I'll help you build [feature]. Let me understand your codebase first.

[Perform research on relevant files/context]

Based on my research, this looks like a [SIMPLE/COMPLEX] feature.

I'll generate a plan now: @generate-plan.md

[Auto-invoke generate-plan command]
```

### 3. Question vs Implementation Detection

**Questions** (DO NOT auto-generate plans):

- "How does [X] work?"
- "Why is [Y] happening?"
- "What is [Z]?"
- "Explain [concept]"
- "Can you show me [example]"

**Auto-response**: Stay in RESEARCH mode, answer question, do NOT trigger plan generation.

**Implementation Requests** (DO auto-generate plans):

- Contains action verbs: build, create, add, implement, fix, refactor, migrate
- Describes desired outcome or feature
- Mentions files/components to modify

**Auto-response**: Enter RESEARCH ‚Üí Auto-trigger plan generation ‚Üí INNOVATE ‚Üí PLAN ‚Üí await approval for EXECUTE

### 4. Trivial vs Non-Trivial Classification

**TRIVIAL (Skip plan generation, offer direct fix):**

- Single line changes (typos, config values)
- Comment additions
- Formatting fixes
- Simple text/message updates
- Adding console.log or debug statements

**Auto-response**:

```
[MODE: RESEARCH]

This is a simple fix. I can do this directly without a plan.

[Show the change]

Should I apply this? (yes/no)
```

**NON-TRIVIAL (Auto-generate plan):**

- New features (any size)
- Multi-file changes
- Logic modifications
- API/database changes
- Architecture decisions

**Auto-response**: Full RIPER-5 workflow with plan generation.

### 5. Context File Auto-Generation

**When to auto-suggest context generation:**

- First conversation in a project
- `.cursor/context/all-context.md` doesn't exist
- User mentions "existing project" or "my codebase"

**Auto-suggestion format:**

```
[MODE: RESEARCH]

I notice you're working with an existing project but there's no context file yet.

Should I scan your codebase to understand your:
- Tech stack
- Architecture
- Conventions
- Environment setup

Run: @generate-context.md? (yes/no)
```

**Do NOT auto-run** - always ask first (scanning can be time-consuming).

### 6. Plan File Auto-Detection

**When plan file exists** (`.cursor/plans/[feature]_PLAN_*.md` attached or mentioned):

1. **Auto-read "What's Functional Now" section**
2. **Auto-detect current phase** (‚úÖ/üöß/‚è≥)
3. **Auto-resume from last incomplete phase**

**Auto-response**:

```
[MODE: RESEARCH]

I see you're continuing work on [feature] (Plan dated [date]).

Current status:
- ‚úÖ Phase 1: Complete
- üöß Phase 2: In progress
- ‚è≥ Phase 3: Planned

Should I continue with Phase 2? (yes/no)
```

### 7. Explicit Command Override

**If user uses explicit commands, DO NOT auto-trigger:**

- `@generate-plan.md` - User is manually creating plan
- `@generate-context.md` - User is manually creating context
- `ENTER [MODE] MODE` - User is manually controlling modes

**Honor explicit commands** - do not second-guess or auto-trigger additional workflows.

### 8. Plan Continuation vs New Feature Detection

**Plan Continuation (Fast-track to EXECUTE):**

Detect when user says:

- "continue [plan-name]"
- "next phase" or "Phase X" (when plan attached)
- "implement [feature]" with existing plan file open/attached

**Validation checks before fast-tracking:**

1. Plan file exists and is attached/referenced
2. Current phase has ‚úÖ (complete) or üöß (in progress) markers
3. Next phase specifications are detailed and unambiguous
4. Sample data or fixtures available (if needed)

**Auto-response pattern:**

```
[MODE: RESEARCH]

Continuing [feature-name] from existing plan (dated [date]).

Current status:
- ‚úÖ Phase 1: [description]
- ‚úÖ Phase 2: [description]
- ‚è≥ Phase 3: [description] - **NEXT**

Phase 3 specs:
- [Key implementation detail 1]
- [Key implementation detail 2]
- Acceptance: [criteria]

This is straightforward execution from the approved plan.

Should I proceed? Reply "ENTER EXECUTE MODE"
```

**New Feature (Full RIPER-5 workflow):**

Detect when:

- No existing plan file for the feature
- User describes desired outcome without specifications
- Request requires architecture decisions
- Multiple implementation approaches possible

**Auto-response pattern:**

```
[MODE: RESEARCH]

I'll help you build [feature]. Let me understand your codebase first.

[Perform research]

Based on my research, this looks like a [SIMPLE/COMPLEX] feature.

I'll generate a plan now: @generate-plan.md
```

### 9. Complexity Evaluation Criteria

**Execute without new plan when:**

- Existing plan file with clear next phase
- Specifications complete and unambiguous
- No architectural decisions needed
- Sample data/fixtures provided

**Generate plan when:**

- No existing plan for this feature
- User describes goal but no specifications
- Multiple approaches need evaluation
- Cross-cutting concerns or dependencies

## Auto-Transition Logic

### Smooth Mode Transitions

**RESEARCH ‚Üí INNOVATE**:

- Auto-transition when research is complete
- Ask: "I've completed research. Should I explore implementation approaches? (say 'go')"

**INNOVATE ‚Üí PLAN**:

- Auto-transition when approach is decided
- Auto-extract/update implementation checklist from plan file

**PLAN ‚Üí EXECUTE**:

- **NEVER auto-transition** - always require explicit "ENTER EXECUTE MODE"
- This is a critical safety checkpoint

**EXECUTE ‚Üí REVIEW**:

- Auto-transition after implementation complete
- Auto-perform self-review
- Auto-flag deviations

**REVIEW ‚Üí UPDATE PROCESS**:

- Auto-suggest if deviations found
- Ask: "I found deviations from the plan. Should I ENTER UPDATE PROCESS MODE to reconcile? (yes/no)"

## Examples

### Example 1: Feature Request with Auto-Detection

**User**: "I want to add a dark mode toggle to my app"

**AI Response**:

```
[MODE: RESEARCH]

I'll help you add a dark mode toggle. Let me understand your current setup first.

[Reads relevant files: theme config, layout, components]

Based on my research:
- You're using Tailwind CSS v4
- No existing theme system detected
- This is a SIMPLE feature (one-session)

Generating plan now...

@generate-plan.md
[Auto-invokes command, creates dark-mode-toggle_PLAN_06-11-25.md]

Plan created! Moving to INNOVATE mode to explore approaches.

[MODE: INNOVATE]
[Discusses implementation options]
```

### Example 2: Question (No Auto-Trigger)

**User**: "How does authentication work in my app?"

**AI Response**:

```
[MODE: RESEARCH]

Let me examine your authentication setup.

[Reads auth files, middleware, config]

Your app uses Clerk for authentication:
- Protected routes via middleware
- User session management in tRPC context
- Role-based access control

[Explains architecture]

Is there anything specific about authentication you'd like to change or improve?
```

### Example 3: Trivial Fix (Direct Offer)

**User**: "Fix the typo in the landing page header"

**AI Response**:

```
[MODE: RESEARCH]

Found the typo in `app/landing/page.tsx` line 42:
- "Welcom" ‚Üí "Welcome"

This is a simple fix. I can apply it directly without a plan.

Should I fix it? (yes/no)
```

### Example 4: Context File Missing

**User**: "Add a user profile page to my Next.js app"

**AI Response**:

```
[MODE: RESEARCH]

I notice this project doesn't have a context file yet.

Should I run `@generate-context.md` first to understand your:
- Tech stack and versions
- Project structure
- Existing conventions
- API patterns

This will help me create a better plan for your user profile page. (yes/no)
```

## Enforcement Rules

- ‚úÖ Auto-detect intent EVERY conversation
- ‚úÖ Auto-enter RESEARCH mode by default
- ‚úÖ Auto-trigger plan generation for non-trivial features
- ‚úÖ Auto-suggest context generation if missing
- ‚úÖ Auto-resume from plan files when provided
- ‚ùå NEVER auto-execute code without explicit approval
- ‚ùå NEVER skip RESEARCH mode (even for simple requests)
- ‚ùå NEVER auto-transition to EXECUTE mode

## Backward Compatibility

**All existing commands still work:**

- `@generate-plan.md` - Manual plan generation
- `@generate-context.md` - Manual context generation
- `ENTER [MODE] MODE` - Manual mode transitions
- `go` - Sequential mode advancement

**Auto-detection enhances, does not replace** explicit commands.

### 8. Sync Command Exemption

When the user invokes `@sync-to-riper5.md`, bypass any requirement to enter `riper-5-mode` before running the sync workflow and just run the command directly to sync. Stay in the current mode unless the user issues a different explicit mode command, then execute the sync steps directly (detect project, confirm scope, verify target repo, show pending changes, sync with confirmations, commit, ask about push). This keeps the sync operation fast and avoids redundant mode transitions.
