{"version":3,"file":"index.tsx-BmfMM3mh.js","sources":["../../src/utils/wait.ts","../../src/pages/content/background-log.ts","../../src/pages/content/extract-author-info.ts","../../src/pages/content/extract-post-content.ts","../../src/pages/content/generate-comment.ts","../../src/pages/content/post-comment-on-post.ts","../../src/pages/content/scroll-feed-load-post.ts","../../src/pages/content/index.tsx"],"sourcesContent":["// Utility function to wait\nexport default function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","// Background logging functions to send logs to background script\nconst backgroundLog = (...args: any[]) => {\n  console.log(...args); // Still log to content script console\n  chrome.runtime\n    .sendMessage({\n      action: \"backgroundLog\",\n      level: \"log\",\n      args: args,\n    })\n    .catch(() => {\n      /* ignore if background script not available */\n    });\n};\n\nconst backgroundError = (...args: any[]) => {\n  console.error(...args); // Still log to content script console\n  chrome.runtime\n    .sendMessage({\n      action: \"backgroundLog\",\n      level: \"error\",\n      args: args,\n    })\n    .catch(() => {\n      /* ignore if background script not available */\n    });\n};\n\nconst backgroundWarn = (...args: any[]) => {\n  console.warn(...args); // Still log to content script console\n  chrome.runtime\n    .sendMessage({\n      action: \"backgroundLog\",\n      level: \"warn\",\n      args: args,\n    })\n    .catch(() => {\n      /* ignore if background script not available */\n    });\n};\n\nconst backgroundGroup = (...args: any[]) => {\n  console.group(...args); // Still log to content script console\n  chrome.runtime\n    .sendMessage({\n      action: \"backgroundLog\",\n      level: \"group\",\n      args: args,\n    })\n    .catch(() => {\n      /* ignore if background script not available */\n    });\n};\n\nconst backgroundGroupEnd = () => {\n  console.groupEnd(); // Still log to content script console\n  chrome.runtime\n    .sendMessage({\n      action: \"backgroundLog\",\n      level: \"groupEnd\",\n      args: [],\n    })\n    .catch(() => {\n      /* ignore if background script not available */\n    });\n};\n\nexport {\n  backgroundLog,\n  backgroundError,\n  backgroundWarn,\n  backgroundGroup,\n  backgroundGroupEnd,\n};\n","// Function to extract author info from post container\nexport default function extractAuthorInfo(\n  postContainer: HTMLElement,\n): { name: string } | null {\n  try {\n    // Look for author container within the post\n    const authorContainer = postContainer.querySelector(\n      \".update-components-actor__container\",\n    );\n    if (!authorContainer) {\n      console.log(\"Author container not found\");\n      return null;\n    }\n\n    // Try different selectors for author name\n    const nameSelectors = [\n      '.update-components-actor__title span[dir=\"ltr\"] span[aria-hidden=\"true\"]',\n      '.update-components-actor__title span[aria-hidden=\"true\"]',\n      \".update-components-actor__title\",\n      \".update-components-actor__name\",\n    ];\n\n    for (const selector of nameSelectors) {\n      const nameElement = authorContainer.querySelector(selector);\n      if (nameElement && nameElement.textContent) {\n        const name = nameElement!\n          .textContent!.replace(/<!---->/g, \"\")\n          .trim()\n          .split(\"‚Ä¢\")[0]\n          .trim();\n        if (name) {\n          console.log(`Extracted author name: ${name}`);\n          return { name };\n        }\n      }\n    }\n\n    console.log(\"Could not extract author name\");\n    return null;\n  } catch (error) {\n    console.error(\"Error extracting author info:\", error);\n    return null;\n  }\n}\n","// Function to extract post content from post container\nexport default function extractPostContent(postContainer: HTMLElement): string {\n  try {\n    // Look for the content container within the post\n    // const contentContainer = postContainer.querySelector('.fie-impression-container');\n    const contentContainer = postContainer.querySelector(\n      \".feed-shared-inline-show-more-text\",\n    );\n    if (!contentContainer) {\n      console.log(\"Content container not found\");\n      return \"\";\n    }\n\n    // Extract text content recursively\n    function extractText(node: Node): string {\n      let text = \"\";\n      node.childNodes.forEach((child) => {\n        if (child.nodeType === Node.TEXT_NODE) {\n          text += child.textContent?.trim() + \" \";\n        } else if (child.nodeType === Node.ELEMENT_NODE) {\n          text += extractText(child);\n        }\n      });\n      return text;\n    }\n\n    const content = extractText(contentContainer).replace(/\\s+/g, \" \").trim();\n    console.log(`Extracted post content: ${content.substring(0, 100)}...`);\n    return content;\n  } catch (error) {\n    console.error(\"Error extracting post content:\", error);\n    return \"\";\n  }\n}\n","// Function to generate comment using background script\nexport default async function generateComment(\n  postContent: string,\n): Promise<string> {\n  return new Promise((resolve) => {\n    console.log(\n      \"ü§ñ Requesting comment generation for post content:\",\n      postContent.substring(0, 200) + \"...\",\n    );\n\n    // Set up a 30-second timeout\n    const timeout = setTimeout(() => {\n      console.error(\n        \"‚è∞ FALLBACK REASON: Comment generation timed out after 30 seconds\",\n      );\n      console.error(\n        \"‚è∞ TIMEOUT - No response from background script within 30 seconds\",\n      );\n      resolve(\"Great post! Thanks for sharing.\");\n    }, 30000);\n\n    // Retry mechanism for connection issues\n    const attemptGeneration = (attempt: number = 1): void => {\n      console.log(\n        `üîÑ Attempt ${attempt}/3: Sending comment generation request...`,\n      );\n\n      chrome.runtime.sendMessage(\n        {\n          action: \"generateComment\",\n          postContent: postContent,\n        },\n        (response) => {\n          clearTimeout(timeout); // Clear the timeout since we got a response\n\n          if (chrome.runtime.lastError) {\n            console.error(\n              `üí• ATTEMPT ${attempt} FAILED - Chrome runtime error:`,\n              chrome.runtime.lastError,\n            );\n\n            // Check if it's a connection error and retry\n            if (\n              chrome.runtime.lastError.message?.includes(\n                \"Could not establish connection\",\n              ) &&\n              attempt < 3\n            ) {\n              console.log(\n                `üîÑ Connection error detected, retrying in 2 seconds... (attempt ${\n                  attempt + 1\n                }/3)`,\n              );\n              setTimeout(() => {\n                attemptGeneration(attempt + 1);\n              }, 2000);\n              return;\n            }\n\n            console.error(\n              \"üí• FALLBACK REASON: Chrome runtime error during comment generation\",\n            );\n            console.error(\"üí• CHROME ERROR:\", chrome.runtime.lastError);\n            console.error(\n              \"üí• This usually means the background script crashed or message passing failed\",\n            );\n            resolve(\"Great post! Thanks for sharing.\");\n          } else if (!response) {\n            console.error(\n              `‚ùå ATTEMPT ${attempt} FAILED - No response received from background script`,\n            );\n\n            // Retry if no response\n            if (attempt < 3) {\n              console.log(\n                `üîÑ No response received, retrying in 2 seconds... (attempt ${\n                  attempt + 1\n                }/3)`,\n              );\n              setTimeout(() => {\n                attemptGeneration(attempt + 1);\n              }, 2000);\n              return;\n            }\n\n            console.error(\n              \"‚ùå FALLBACK REASON: No response received from background script after 3 attempts\",\n            );\n            console.error(\n              \"‚ùå RESPONSE NULL - Background script may have failed silently\",\n            );\n            resolve(\"Great post! Thanks for sharing.\");\n          } else if (!response.comment) {\n            console.error(\n              \"‚ö†Ô∏è FALLBACK REASON: Response received but no comment field\",\n            );\n            console.error(\"‚ö†Ô∏è INVALID RESPONSE STRUCTURE:\", response);\n            console.error(\n              \"‚ö†Ô∏è Expected response.comment but got:\",\n              Object.keys(response),\n            );\n            resolve(\"Great post! Thanks for sharing.\");\n          } else if (response.comment === \"Great post! Thanks for sharing.\") {\n            console.error(\n              \"üö® FALLBACK REASON: Background script returned the default fallback comment\",\n            );\n            console.error(\n              \"üö® This means the AI API failed and background script used fallback\",\n            );\n\n            // Check if error details were provided in the response\n            if (response.error) {\n              console.group(\"üî• AI API ERROR DETAILS FROM RESPONSE\");\n              console.error(\"üî• Error Message:\", response.error.message);\n              console.error(\"üî• Error Type:\", response.error.name);\n              console.error(\"üî• API Key Status:\", response.error.apiKey);\n              console.error(\n                \"üî• Style Guide Status:\",\n                response.error.styleGuide,\n              );\n              console.error(\n                \"üî• Post Content Length:\",\n                response.error.postContentLength,\n                \"characters\",\n              );\n              if (response.error.stack) {\n                console.error(\"üî• Stack Trace:\", response.error.stack);\n              }\n              console.groupEnd();\n            } else {\n              console.error(\n                \"üö® No error details provided - check background script console\",\n              );\n            }\n\n            resolve(response.comment);\n          } else {\n            console.log(\n              \"‚úÖ Successfully received generated comment:\",\n              response.comment.substring(0, 100) + \"...\",\n            );\n            resolve(response.comment);\n          }\n        },\n      );\n    };\n\n    // Start the first attempt\n    attemptGeneration(1);\n  });\n}\n","import wait from \"@src/utils/wait\";\n\n// Function to post comment on a specific post\nexport default async function postCommentOnPost(\n  postContainer: HTMLElement,\n  comment: string,\n  isCommentingActive: boolean,\n): Promise<boolean> {\n  try {\n    console.group(\"üìù Comment Posting Process\");\n    console.log(\"Starting to post comment:\", comment.substring(0, 100) + \"...\");\n\n    // Check if we should stop before starting\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping comment posting due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 1: Find and click the comment button\n    console.log(\"üîç Looking for comment button...\");\n    const commentButton = postContainer.querySelector(\n      'button[aria-label=\"Comment\"]',\n    ) as HTMLButtonElement;\n    if (!commentButton) {\n      console.error(\"‚ùå Comment button not found\");\n      console.groupEnd();\n      return false;\n    }\n\n    console.log(\"üëÜ Clicking comment button...\");\n    commentButton.click();\n\n    // Wait for comment editor to appear\n    console.log(\"‚è≥ Waiting for comment editor to appear...\");\n    await wait(2000);\n\n    // Check again after wait\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping during comment editor wait due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 2: Find the comment editor\n    console.log(\"üîç Looking for comment editor...\");\n    const commentEditor = postContainer.querySelector(\n      \".comments-comment-box-comment__text-editor\",\n    );\n    if (!commentEditor) {\n      console.error(\"‚ùå Comment editor not found\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 3: Find the editable field within the editor\n    console.log(\"üîç Looking for editable field...\");\n    const editableField = commentEditor.querySelector(\n      'div[contenteditable=\"true\"]',\n    ) as HTMLElement;\n    if (!editableField) {\n      console.error(\"‚ùå Editable field not found\");\n      console.groupEnd();\n      return false;\n    }\n\n    console.log(\"‚úÖ Found editable field, inputting comment...\");\n\n    // Check again before inputting\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping during comment input due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 4: Click on the editable field and input the comment\n    editableField.focus();\n    editableField.click();\n    editableField.innerHTML = \"\";\n\n    // Input the comment text\n    const lines = comment.split(\"\\n\");\n    lines.forEach((lineText) => {\n      const p = document.createElement(\"p\");\n      if (lineText === \"\") {\n        p.appendChild(document.createElement(\"br\"));\n      } else {\n        p.textContent = lineText;\n      }\n      editableField.appendChild(p);\n    });\n\n    // Set cursor position and trigger input event\n    const selection = window.getSelection();\n    if (selection) {\n      const range = document.createRange();\n      if (editableField.lastChild) {\n        range.setStartAfter(editableField.lastChild);\n      } else {\n        range.selectNodeContents(editableField);\n      }\n      range.collapse(true);\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    editableField.focus();\n\n    const inputEvent = new Event(\"input\", { bubbles: true, cancelable: true });\n    editableField.dispatchEvent(inputEvent);\n\n    console.log(\"‚úÖ Comment text inputted successfully\");\n\n    // Wait for submit button to become enabled\n    console.log(\"‚è≥ Waiting for submit button to become enabled...\");\n    await wait(1000);\n\n    // Check again before submitting\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping during submit button wait due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 5: Find and click the submit button\n    console.log(\"üîç Looking for submit button...\");\n    const submitButton = postContainer.querySelector(\n      \".comments-comment-box__submit-button--cr\",\n    ) as HTMLButtonElement;\n    if (!submitButton || submitButton.disabled) {\n      console.error(\"‚ùå Submit button not found or disabled\");\n      console.groupEnd();\n      return false;\n    }\n\n    console.log(\"üöÄ Clicking submit button...\");\n    submitButton.click();\n\n    // Wait for comment to be posted\n    console.log(\"‚è≥ Waiting for comment to be posted...\");\n    await wait(2000);\n\n    console.log(\"üéâ Comment posted successfully\");\n    console.groupEnd();\n    return true;\n  } catch (error) {\n    console.error(\"üí• Error posting comment:\", error);\n    console.groupEnd();\n    return false;\n  }\n}\n","import wait from \"@src/utils/wait\";\n\n// Helper function to manually trigger scroll events for better LinkedIn compatibility\nfunction triggerScrollEvents() {\n  try {\n    // Create scroll event (following the 10-year-old solution approach)\n    const scrollEvent = new Event(\"scroll\", {\n      bubbles: true,\n      cancelable: true,\n    });\n\n    // Method 1: Traditional window/document events\n    window.dispatchEvent(scrollEvent);\n    document.dispatchEvent(scrollEvent);\n\n    // Method 2: Target LinkedIn's specific feed containers (key insight from old solution)\n    const linkedInFeedSelectors = [\n      \".scaffold-layout__main\", // Main content area\n      \".feed-container-theme\", // Feed container\n      \".scaffold-finite-scroll\", // Infinite scroll container\n      \".feed-shared-update-v2\", // Individual post containers\n      \".application-outlet\", // Main app container\n      \".feed-outlet\", // Feed outlet\n      \"#main\", // Main element\n      '[role=\"main\"]', // ARIA main role\n      \".ember-application\", // Ember app container\n    ];\n\n    // Dispatch scroll events to each LinkedIn container we can find\n    linkedInFeedSelectors.forEach((selector) => {\n      const elements = document.querySelectorAll(selector);\n      elements.forEach((element) => {\n        if (element) {\n          element.dispatchEvent(scrollEvent);\n          console.log(`Triggered scroll event on: ${selector}`);\n        }\n      });\n    });\n\n    // Method 3: Also trigger wheel events (some sites listen for these)\n    const wheelEvent = new WheelEvent(\"wheel\", {\n      bubbles: true,\n      cancelable: true,\n      deltaY: 100,\n      deltaMode: WheelEvent.DOM_DELTA_PIXEL,\n    });\n    window.dispatchEvent(wheelEvent);\n\n    // Trigger wheel events on main containers too\n    const mainContainer = document.querySelector(\n      \".scaffold-layout__main, .feed-container-theme\",\n    );\n    if (mainContainer) {\n      mainContainer.dispatchEvent(wheelEvent);\n      console.log(\"Triggered wheel event on main LinkedIn container\");\n    }\n  } catch (error) {\n    console.error(\"Failed to trigger scroll events:\", error);\n  }\n}\n\n// Function to scroll feed and load posts - Aggressive scrolling to bottom\nexport default async function scrollFeedLoadPosts(\n  duration: number,\n  isCommentingActive: boolean,\n  statusPanel?: HTMLDivElement,\n): Promise<void> {\n  console.log(\n    `Aggressively scrolling feed for ${duration} seconds to load posts...`,\n  );\n\n  const startTime = Date.now();\n  const endTime = startTime + duration * 1000;\n\n  // Track metrics for debugging\n  let scrollAttempts = 0;\n  let postCountBefore = 0;\n  let lastPostCount = 0;\n\n  // Get initial post count\n  const initialPosts = document.querySelectorAll(\n    \".feed-shared-update-v2__control-menu-container\",\n  );\n  postCountBefore = initialPosts.length;\n  lastPostCount = postCountBefore;\n\n  // Use aggressive scrolling - just go to bottom repeatedly\n  const pauseBetweenScrolls = 2000; // 2 second pause to allow content loading\n\n  while (Date.now() < endTime && isCommentingActive) {\n    // Check if we should stop\n    if (!isCommentingActive) {\n      break;\n    }\n\n    const currentTime = Date.now();\n    const timeRemaining = Math.round((endTime - currentTime) / 1000);\n\n    // Update status panel if available\n    if (statusPanel) {\n      const currentPosts = document.querySelectorAll(\n        \".feed-shared-update-v2__control-menu-container\",\n      ).length;\n      const newPostsThisSession = currentPosts - postCountBefore;\n\n      const timeRemainingElement = statusPanel.querySelector(\n        \"#time-remaining span\",\n      );\n      const postsLoadedElement =\n        statusPanel.querySelector(\"#posts-loaded span\");\n      const scrollProgressElement = statusPanel.querySelector(\n        \"#scroll-progress span\",\n      );\n\n      if (timeRemainingElement) {\n        timeRemainingElement.textContent = `${timeRemaining}s`;\n      }\n\n      if (postsLoadedElement) {\n        postsLoadedElement.textContent = `${currentPosts} posts (+${newPostsThisSession} this session)`;\n      }\n\n      if (scrollProgressElement) {\n        scrollProgressElement.textContent = `Scroll attempt ${\n          scrollAttempts + 1\n        } - Loading content...`;\n      }\n    }\n\n    scrollAttempts++;\n\n    // Record current scroll position\n    const beforeScroll = window.scrollY;\n    const documentHeight = document.body.scrollHeight;\n\n    // Aggressive scroll: Go straight to bottom\n    window.scrollTo({ top: documentHeight, behavior: \"smooth\" });\n\n    // Trigger scroll events on LinkedIn's specific containers\n    triggerScrollEvents();\n\n    // Wait for scroll to complete and content to load\n    await wait(pauseBetweenScrolls);\n\n    const afterScroll = window.scrollY;\n    const newDocumentHeight = document.body.scrollHeight;\n\n    // Check for new content after each scroll\n    const currentPosts = document.querySelectorAll(\n      \".feed-shared-update-v2__control-menu-container\",\n    );\n    const newPostCount = currentPosts.length;\n\n    if (newPostCount > lastPostCount) {\n      const newPosts = newPostCount - lastPostCount;\n      lastPostCount = newPostCount;\n\n      // Update status panel with success indicator\n      if (statusPanel) {\n        const scrollProgressElement = statusPanel.querySelector(\n          \"#scroll-progress span\",\n        );\n        if (scrollProgressElement) {\n          scrollProgressElement.textContent = `‚úÖ Loaded ${newPosts} new posts! (Total: ${newPostCount})`;\n        }\n      }\n    } else {\n      // Update status panel with no new content indicator\n      if (statusPanel) {\n        const scrollProgressElement = statusPanel.querySelector(\n          \"#scroll-progress span\",\n        );\n        if (scrollProgressElement) {\n          scrollProgressElement.textContent = `‚è≥ Waiting for new content... (${newPostCount} posts)`;\n        }\n      }\n    }\n  }\n\n  // Final status update\n  if (statusPanel) {\n    const finalPosts = document.querySelectorAll(\n      \".feed-shared-update-v2__control-menu-container\",\n    );\n    const totalNewPosts = finalPosts.length - postCountBefore;\n\n    const timeRemainingElement = statusPanel.querySelector(\n      \"#time-remaining span\",\n    );\n    const scrollProgressElement = statusPanel.querySelector(\n      \"#scroll-progress span\",\n    );\n\n    if (timeRemainingElement) {\n      timeRemainingElement.textContent = `0s - COMPLETE!`;\n    }\n\n    if (scrollProgressElement) {\n      scrollProgressElement.textContent = `üéâ Scrolling complete! Loaded ${totalNewPosts} new posts`;\n    }\n  }\n\n  // Final metrics\n  const finalPosts = document.querySelectorAll(\n    \".feed-shared-update-v2__control-menu-container\",\n  );\n  const totalNewPosts = finalPosts.length - initialPosts.length;\n  const actualDuration = Math.round((Date.now() - startTime) / 1000);\n\n  console.log(\"Finished aggressive scrolling to load posts\");\n}\n","import wait from \"@src/utils/wait\";\n\nimport {\n  backgroundError,\n  backgroundGroup,\n  backgroundGroupEnd,\n  backgroundLog,\n  backgroundWarn,\n} from \"./background-log\";\nimport extractAuthorInfo from \"./extract-author-info\";\nimport extractPostContent from \"./extract-post-content\";\nimport generateComment from \"./generate-comment\";\nimport postCommentOnPost from \"./post-comment-on-post\";\nimport scrollFeedLoadPosts from \"./scroll-feed-load-post\";\n\n// Content script for EngageKit - Background Window Mode\n// This script processes posts directly on the feed page\n\nlet isCommentingActive = false;\nlet commentedAuthors = new Set<string>();\nlet commentedAuthorsWithTimestamps = new Map<string, number>();\nlet postsSkippedDuplicateCount = 0;\nlet recentAuthorsDetectedCount = 0;\nlet commentedPostUrns = new Map<string, number>(); // URN -> timestamp\nlet postsSkippedAlreadyCommentedCount = 0;\nlet duplicatePostsDetectedCount = 0;\nlet postsSkippedTimeFilterCount = 0;\nlet audioContext: AudioContext | null = null;\nlet currentOscillator: OscillatorNode | null = null;\nlet audioElement: HTMLAudioElement | null = null;\n\n// Check if we need to show the start button\nlet hasUserInteracted = false;\n\n//check if page is ready to display the start button\nif (document.readyState !== \"loading\") {\n  console.log(\"document is already ready, just execute code here\");\n  //send page ready message to background script\n  chrome.runtime.sendMessage({\n    action: \"pageReady\",\n  });\n} else {\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    console.log(\"document was not ready, place code here\");\n    //send page ready message to background script\n    chrome.runtime.sendMessage({\n      action: \"pageReady\",\n    });\n  });\n}\n\n// Function to show the start button overlay\nfunction showStartButton() {\n  console.log(\"üöÄ Showing start button for EngageKit...\");\n\n  // Don't show multiple buttons\n  if (document.getElementById(\"linkedin-start-overlay\")) {\n    return;\n  }\n\n  // Create full-screen overlay\n  const overlay = document.createElement(\"div\");\n  overlay.id = \"linkedin-start-overlay\";\n  overlay.style.cssText = `\n    position: fixed !important;\n    top: 0 !important;\n    left: 0 !important;\n    width: 100vw !important;\n    height: 100vh !important;\n    background: rgba(0, 115, 177, 0.95) !important;\n    z-index: 2147483647 !important;\n    display: flex !important;\n    flex-direction: column !important;\n    justify-content: center !important;\n    align-items: center !important;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif !important;\n    color: white !important;\n  `;\n\n  // Create container\n  const container = document.createElement(\"div\");\n  container.style.cssText = `\n    text-align: center !important;\n    max-width: 600px !important;\n    padding: 40px !important;\n    background: rgba(255, 255, 255, 0.1) !important;\n    border-radius: 20px !important;\n    backdrop-filter: blur(10px) !important;\n  `;\n\n  // Create title\n  const title = document.createElement(\"h1\");\n  title.textContent = \"EngageKit\";\n  title.style.cssText = `\n    font-size: 48px !important;\n    margin: 0 0 20px 0 !important;\n    text-align: center !important;\n    font-weight: bold !important;\n    color: white !important;\n  `;\n\n  // Create subtitle\n  const subtitle = document.createElement(\"p\");\n  subtitle.textContent = \"Click to start auto-commenting on LinkedIn posts\";\n  subtitle.style.cssText = `\n    font-size: 20px !important;\n    margin: 0 0 40px 0 !important;\n    text-align: center !important;\n    opacity: 0.9 !important;\n    color: white !important;\n  `;\n\n  // Create start button\n  const startButton = document.createElement(\"button\");\n  startButton.textContent = \"üöÄ Start Auto-Commenting\";\n  startButton.style.cssText = `\n    background: #ffffff !important;\n    color: #0073b1 !important;\n    border: none !important;\n    padding: 20px 40px !important;\n    font-size: 24px !important;\n    font-weight: bold !important;\n    border-radius: 12px !important;\n    cursor: pointer !important;\n    box-shadow: 0 8px 16px rgba(0,0,0,0.2) !important;\n    transition: all 0.3s ease !important;\n    margin: 0 0 20px 0 !important;\n    font-family: inherit !important;\n  `;\n\n  // Add hover effects\n  startButton.addEventListener(\"mouseenter\", () => {\n    startButton.style.transform = \"translateY(-2px)\";\n    startButton.style.boxShadow = \"0 12px 20px rgba(0,0,0,0.3)\";\n  });\n\n  startButton.addEventListener(\"mouseleave\", () => {\n    startButton.style.transform = \"translateY(0)\";\n    startButton.style.boxShadow = \"0 8px 16px rgba(0,0,0,0.2)\";\n  });\n\n  // Create info text\n  const infoText = document.createElement(\"p\");\n  infoText.innerHTML = `\n    <strong>What will happen:</strong><br>\n    ‚Ä¢ Audio will start playing to keep this tab active<br>\n    ‚Ä¢ This window will move to the background<br>\n    ‚Ä¢ Auto-commenting will begin immediately<br>\n    ‚Ä¢ You can continue using other applications\n  `;\n  infoText.style.cssText = `\n    font-size: 16px !important;\n    text-align: center !important;\n    opacity: 0.8 !important;\n    line-height: 1.6 !important;\n    max-width: 500px !important;\n    margin: 0 !important;\n    color: white !important;\n  `;\n\n  // Button click handler\n  startButton.addEventListener(\"click\", async () => {\n    console.log(\"üöÄ Start button clicked! Beginning full flow...\");\n    hasUserInteracted = true;\n\n    // Update button state\n    startButton.textContent = \"üîÑ Starting...\";\n    startButton.style.background = \"#28a745\";\n    startButton.style.color = \"white\";\n    startButton.disabled = true;\n\n    try {\n      // Step 1: Start continuous audio\n      console.log(\"üéµ Step 1: Starting continuous audio...\");\n      await injectAndPlayContinuousSound();\n\n      startButton.textContent = \"üéµ Audio Started\";\n\n      await wait(1000);\n      startButton.textContent = \"üí¨ Starting flow\";\n      //step 2: move back to the original tab\n\n      // Get settings from storage and start commenting\n      chrome.storage.local.get(\n        [\n          \"scrollDuration\",\n          \"commentDelay\",\n          \"maxPosts\",\n          \"duplicateWindow\",\n          \"styleGuide\",\n          \"apiKey\",\n        ],\n        (result) => {\n          backgroundLog(\"Content: Retrieved settings from storage:\", result);\n\n          // Use popup settings with fallbacks only if completely missing\n          const scrollDuration =\n            result.scrollDuration !== undefined ? result.scrollDuration : 10;\n          const commentDelay =\n            result.commentDelay !== undefined ? result.commentDelay : 5;\n          const maxPosts = result.maxPosts !== undefined ? result.maxPosts : 5;\n          const duplicateWindow =\n            result.duplicateWindow !== undefined ? result.duplicateWindow : 24;\n          const styleGuide =\n            result.styleGuide !== undefined\n              ? result.styleGuide\n              : \"Be engaging and professional\";\n          const apiKey = result.apiKey !== undefined ? result.apiKey : \"\";\n\n          backgroundLog(\"üéØ Starting commenting flow with settings:\", {\n            scrollDuration,\n            commentDelay,\n            maxPosts,\n            styleGuide: styleGuide?.substring(0, 50) + \"...\",\n            hasApiKey: !!apiKey,\n          });\n\n          // API key check removed - using server-side tRPC API now\n\n          if (!styleGuide) {\n            backgroundError(\n              \"‚ùå No style guide found in storage! Cannot start commenting.\",\n            );\n            return;\n          }\n\n          // Update button status for scrolling phase\n          startButton.textContent = `üìú Scrolling to load posts (${scrollDuration}s) - DON'T navigate away!`;\n          startButton.style.background = \"#ff9500\";\n          startButton.style.fontSize = \"18px\";\n          subtitle.textContent =\n            \"Loading posts from LinkedIn feed - please keep this tab visible\";\n\n          // Add dynamic status panel to the overlay\n          const statusPanel = document.createElement(\"div\");\n          statusPanel.id = \"linkedin-status-panel\";\n          statusPanel.style.cssText = `\n          background: rgba(255, 255, 255, 0.15) !important;\n          border-radius: 12px !important;\n          padding: 20px !important;\n          margin-top: 20px !important;\n          border: 1px solid rgba(255, 255, 255, 0.3) !important;\n          font-family: monospace !important;\n          font-size: 14px !important;\n          line-height: 1.6 !important;\n        `;\n\n          const initialPosts = document.querySelectorAll(\n            \".feed-shared-update-v2__control-menu-container\",\n          ).length;\n\n          statusPanel.innerHTML = `\n          <div style=\"color: white !important; margin-bottom: 12px !important;\">\n            <strong>üìä AUTOMATION SETTINGS</strong>\n          </div>\n          <div style=\"color: #e0e0e0 !important; margin-bottom: 8px !important;\">\n            üìú Scroll Duration: <span style=\"color: #90EE90 !important;\">${scrollDuration} seconds</span>\n          </div>\n          <div style=\"color: #e0e0e0 !important; margin-bottom: 8px !important;\">\n            ‚è±Ô∏è Comment Delay: <span style=\"color: #90EE90 !important;\">${commentDelay} seconds</span>\n          </div>\n          <div style=\"color: #e0e0e0 !important; margin-bottom: 16px !important;\">\n            üéØ Max Posts: <span style=\"color: #90EE90 !important;\">${maxPosts} posts</span>\n          </div>\n          \n          <div style=\"color: white !important; margin-bottom: 12px !important;\">\n            <strong>üìà REAL-TIME STATUS</strong>\n          </div>\n          <div id=\"time-remaining\" style=\"color: #FFD700 !important; margin-bottom: 8px !important;\">\n            ‚è∞ Time Remaining: <span style=\"color: #FFA500 !important;\">${scrollDuration}s</span>\n          </div>\n          <div id=\"posts-loaded\" style=\"color: #87CEEB !important; margin-bottom: 8px !important;\">\n            üìù Posts Loaded: <span style=\"color: #00BFFF !important;\">${initialPosts} posts</span>\n          </div>\n          <div id=\"scroll-progress\" style=\"color: #DDA0DD !important;\">\n            üîÑ Status: <span style=\"color: #DA70D6 !important;\">Starting scroll...</span>\n          </div>\n        `;\n\n          // Add status panel to the container (after the info text)\n          const container = overlay.querySelector(\"div\");\n          if (container) {\n            container.appendChild(statusPanel);\n          }\n\n          // Start the commenting flow but delay tab switching until after scrolling\n          startNewCommentingFlowWithDelayedTabSwitch(\n            scrollDuration,\n            commentDelay,\n            maxPosts,\n            styleGuide,\n            duplicateWindow,\n            overlay,\n            startButton,\n            subtitle,\n            statusPanel,\n          );\n        },\n      );\n\n      // Don't remove overlay here - let the commenting flow handle it\n\n      console.log(\"‚úÖ Full flow started successfully!\");\n    } catch (error) {\n      console.error(\"‚ùå Failed to start:\", error);\n      startButton.textContent = \"‚ùå Failed - Try Again\";\n      startButton.style.background = \"#dc3545\";\n      startButton.disabled = false;\n      subtitle.textContent = \"Something went wrong - click to try again\";\n    }\n  });\n\n  // Assemble UI\n  container.appendChild(title);\n  container.appendChild(subtitle);\n  container.appendChild(startButton);\n  container.appendChild(infoText);\n  overlay.appendChild(container);\n\n  // Add to page\n  document.body.appendChild(overlay);\n\n  console.log(\"üöÄ Start button overlay displayed\");\n}\n\n// --- Main function to create and play the continuous audio ---\nasync function injectAndPlayContinuousSound(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    try {\n      console.log(\"üéµ Initializing Web Audio API for continuous sound...\");\n\n      // Get the AudioContext constructor, working across browsers\n      const AudioContext =\n        window.AudioContext || (window as any).webkitAudioContext;\n\n      // Check if Web Audio API is supported\n      if (!AudioContext) {\n        throw new Error(\n          \"Web Audio API is not supported in this browser. Cannot play audio.\",\n        );\n      }\n\n      // Create an AudioContext instance\n      // This is the gateway to using the Web Audio API\n      audioContext = new AudioContext();\n\n      // --- Sound Generation Setup ---\n\n      // Create an OscillatorNode: This will generate the actual sound wave\n      const oscillator = audioContext.createOscillator();\n\n      // Create a GainNode: This will control the volume of the sound\n      const gainNode = audioContext.createGain();\n\n      // Create a MediaStreamDestinationNode: This allows us to take the audio\n      // generated by the Web Audio API and use it as a source for an HTML <audio> element.\n      const mediaStreamDestination =\n        audioContext.createMediaStreamDestination();\n\n      // Connect the nodes: Oscillator -> GainNode -> MediaStreamDestination\n      // The sound flows from the oscillator, through the volume control (gain),\n      // and then to the stream destination.\n      oscillator.connect(gainNode);\n      gainNode.connect(mediaStreamDestination);\n\n      // --- Configure the Sound ---\n\n      // Set the type of wave for the oscillator\n      // 'sine': a pure, smooth tone\n      // Other options: 'square', 'sawtooth', 'triangle'\n      oscillator.type = \"sine\";\n\n      // Set the frequency (pitch) of the sound in Hertz (Hz)\n      // Let's pick a random frequency in a generally pleasant mid-range (e.g., between C4 and C5)\n      // C4 is approx 261.63 Hz, C5 is approx 523.25 Hz\n      const minFreq = 261.63;\n      const maxFreq = 523.25;\n      // const frequency = Math.random() * (maxFreq - minFreq) + minFreq;\n      const frequency = 10000;\n\n      //picking an inaudible frequency almost zero volume\n      oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);\n\n      // Set the volume using the GainNode\n      // 0.0 is silent, 1.0 is full volume. Let's set it low to be less intrusive.\n      gainNode.gain.setValueAtTime(0.001, audioContext.currentTime); // 10% volume\n\n      // --- HTML <audio> Element Setup ---\n\n      // Create a new HTML <audio> element\n      audioElement = document.createElement(\"audio\");\n\n      // Set the source of the audio element to the stream from our Web Audio API setup\n      audioElement.srcObject = mediaStreamDestination.stream;\n\n      // Set the audio to autoplay\n      // IMPORTANT: Browsers have autoplay restrictions. This might not work without user interaction.\n      audioElement.autoplay = true;\n\n      // Set the audio to loop continuously\n      audioElement.loop = true;\n\n      // Hide the default audio controls for background audio\n      audioElement.controls = false;\n\n      // Hide the audio element\n      audioElement.style.cssText = \"position: fixed; top: -9999px; opacity: 0;\";\n\n      // --- Inject into DOM and Start ---\n\n      // Append the new audio element to the body of the document\n      // This makes it part of the webpage\n      document.body.appendChild(audioElement);\n\n      // Resume AudioContext if needed (for user gesture compliance)\n      const startAudioPlayback = async () => {\n        if (audioContext!.state === \"suspended\") {\n          await audioContext!.resume();\n        }\n\n        // Start the oscillator to begin generating sound\n        // This needs to happen for any sound to be produced\n        oscillator.start();\n        currentOscillator = oscillator;\n\n        // Attempt to play the HTML audio element\n        // This is often needed due to autoplay policies, especially if audioCtx was not started by user gesture.\n        const playPromise = audioElement!.play();\n\n        if (playPromise !== undefined) {\n          playPromise\n            .then(() => {\n              // Autoplay started successfully.\n              console.log(\n                `‚úÖ Playing a ${oscillator.type} wave at ${frequency.toFixed(\n                  2,\n                )} Hz. Audio element injected and playing.`,\n              );\n              resolve();\n            })\n            .catch((error) => {\n              // Autoplay was prevented.\n              console.warn(\"‚ùå Autoplay was prevented by the browser:\", error);\n              reject(error);\n            });\n        } else {\n          console.log(`‚úÖ Audio started successfully (no promise returned)`);\n          resolve();\n        }\n      };\n\n      startAudioPlayback();\n    } catch (error) {\n      console.error(\"‚ùå Audio setup failed:\", error);\n      reject(error);\n    }\n  });\n}\n\n// Listen for messages from the background script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log(\"Content script received message:\", request);\n\n  if (request.action === \"showStartButton\") {\n    console.log(\"üì± Popup requested to show start button\");\n    showStartButton();\n    sendResponse({ success: true });\n  } else if (request.action === \"startNewCommentingFlow\") {\n    startNewCommentingFlowWithDelayedTabSwitch(\n      request.scrollDuration,\n      request.commentDelay,\n      request.maxPosts,\n      request.styleGuide,\n      request.apiKey,\n      request.duplicateWindow || 24, // default to 24 hours if not provided\n      null as any, // overlay not available from this path\n      null as any, // startButton not available from this path\n      null as any, // subtitle not available from this path\n      null as any, // statusPanel not available from this path\n    );\n    sendResponse({ success: true });\n  } else if (request.action === \"stopCommentingFlow\") {\n    console.log(\"Received stop signal - stopping commenting flow\");\n    isCommentingActive = false;\n    stopTabActiveAudio();\n    sendResponse({ success: true });\n  } else if (request.action === \"statusUpdate\" && request.error) {\n    // Log error details to the website console for debugging\n    console.group(\"üö® EngageKit Error Details\");\n    console.error(\"Error Message:\", request.error.message);\n    if (request.error.status) {\n      console.error(\n        \"HTTP Status:\",\n        request.error.status,\n        \"-\",\n        request.error.statusText,\n      );\n    }\n    if (request.error.body) {\n      console.error(\"API Response Body:\", request.error.body);\n    }\n    if (request.error.headers) {\n      console.error(\"Response Headers:\", request.error.headers);\n    }\n    console.error(\"API Key Status:\", request.error.apiKey || \"Unknown\");\n    console.error(\"Style Guide Status:\", request.error.styleGuide || \"Unknown\");\n    if (request.error.postContentLength !== undefined) {\n      console.error(\n        \"Post Content Length:\",\n        request.error.postContentLength,\n        \"characters\",\n      );\n    }\n    if (request.error.stack) {\n      console.error(\"Stack Trace:\", request.error.stack);\n    }\n    if (request.error.data) {\n      console.error(\"Additional Data:\", request.error.data);\n    }\n    console.groupEnd();\n\n    // Also create a visual alert in the page\n    const errorDiv = document.createElement(\"div\");\n    errorDiv.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #fee;\n      border: 2px solid #f00;\n      padding: 15px;\n      border-radius: 8px;\n      z-index: 10000;\n      max-width: 400px;\n      font-family: Arial, sans-serif;\n      font-size: 12px;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    `;\n    errorDiv.innerHTML = `\n      <div style=\"font-weight: bold; color: #d00; margin-bottom: 8px;\">\n        üö® EngageKit Error\n      </div>\n      <div style=\"color: #800; margin-bottom: 5px;\">\n        ${request.error.message || \"Unknown error occurred\"}\n      </div>\n      ${\n        request.error.status\n          ? `<div style=\"color: #600; font-size: 11px;\">HTTP ${request.error.status}: ${request.error.statusText}</div>`\n          : \"\"\n      }\n      <div style=\"color: #600; font-size: 11px; margin-top: 5px;\">\n        Check console for full details (F12)\n      </div>\n      <button onclick=\"this.parentElement.remove()\" style=\"\n        background: #d00;\n        color: white;\n        border: none;\n        padding: 4px 8px;\n        border-radius: 4px;\n        cursor: pointer;\n        font-size: 10px;\n        margin-top: 8px;\n      \">Close</button>\n    `;\n    document.body.appendChild(errorDiv);\n\n    // Auto-remove after 10 seconds\n    setTimeout(() => {\n      if (errorDiv.parentElement) {\n        errorDiv.remove();\n      }\n    }, 10000);\n  }\n});\n\n// Function to get today's date string\nfunction getTodayDateString(): string {\n  return new Date().toDateString();\n}\n\n// Function to load commented authors with timestamps from local storage\nasync function loadCommentedAuthorsWithTimestamps(): Promise<\n  Map<string, number>\n> {\n  const storageKey = \"commented_authors_timestamps\";\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const authorTimestamps = result[storageKey] || {};\n      resolve(\n        new Map(\n          Object.entries(authorTimestamps).map(([name, timestamp]) => [\n            name,\n            Number(timestamp),\n          ]),\n        ),\n      );\n    });\n  });\n}\n\n// Function to save commented author with timestamp to local storage\nasync function saveCommentedAuthorWithTimestamp(\n  authorName: string,\n): Promise<void> {\n  const storageKey = \"commented_authors_timestamps\";\n  const now = Date.now();\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const authorTimestamps = result[storageKey] || {};\n      authorTimestamps[authorName] = now;\n      chrome.storage.local.set({ [storageKey]: authorTimestamps }, () => {\n        console.log(\n          `Saved commented author: ${authorName} at timestamp: ${now}`,\n        );\n        resolve();\n      });\n    });\n  });\n}\n\n// Function to check if author was commented on within the specified time window\nfunction hasCommentedOnAuthorRecently(\n  authorName: string,\n  commentedAuthors: Map<string, number>,\n  hoursWindow: number,\n): boolean {\n  const timestamp = commentedAuthors.get(authorName);\n  if (!timestamp) return false;\n\n  const now = Date.now();\n  const hoursInMs = hoursWindow * 60 * 60 * 1000;\n\n  return now - timestamp < hoursInMs;\n}\n\n// Function to load today's commented authors from local storage (for backward compatibility)\nasync function loadTodayCommentedAuthors(): Promise<Set<string>> {\n  const today = getTodayDateString();\n  const storageKey = `commented_authors_${today}`;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const todayAuthors = result[storageKey] || [];\n      resolve(new Set(todayAuthors));\n    });\n  });\n}\n\n// Function to save commented author to local storage (for backward compatibility)\nasync function saveCommentedAuthor(authorName: string): Promise<void> {\n  const today = getTodayDateString();\n  const storageKey = `commented_authors_${today}`;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const todayAuthors = result[storageKey] || [];\n      if (!todayAuthors.includes(authorName)) {\n        todayAuthors.push(authorName);\n        chrome.storage.local.set({ [storageKey]: todayAuthors }, () => {\n          console.log(`Saved commented author: ${authorName} for ${today}`);\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n// Function to load counter values from storage\nasync function loadCounters(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(\n      [\n        \"postsSkippedDuplicate\",\n        \"recentAuthorsDetected\",\n        \"postsSkippedAlreadyCommented\",\n        \"duplicatePostsDetected\",\n      ],\n      (result) => {\n        postsSkippedDuplicateCount = result.postsSkippedDuplicate || 0;\n        recentAuthorsDetectedCount = result.recentAuthorsDetected || 0;\n        postsSkippedAlreadyCommentedCount =\n          result.postsSkippedAlreadyCommented || 0;\n        duplicatePostsDetectedCount = result.duplicatePostsDetected || 0;\n        console.log(\n          `Loaded counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}, Posts already commented: ${postsSkippedAlreadyCommentedCount}, Duplicate posts detected: ${duplicatePostsDetectedCount}`,\n        );\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to update skipped post counter\nasync function updateSkippedPostCounter(): Promise<void> {\n  postsSkippedDuplicateCount++;\n  recentAuthorsDetectedCount++; // For now both counters increment together\n  duplicatePostsDetectedCount++; // For now, both author filter skips and post URN skips increment this\n\n  return new Promise((resolve) => {\n    chrome.storage.local.set(\n      {\n        postsSkippedDuplicate: postsSkippedDuplicateCount,\n        recentAuthorsDetected: recentAuthorsDetectedCount,\n        duplicatePostsDetected: duplicatePostsDetectedCount,\n      },\n      () => {\n        console.log(\n          `Updated counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}, Duplicate posts detected: ${duplicatePostsDetectedCount}`,\n        );\n\n        // Send real-time update to popup\n        chrome.runtime.sendMessage({\n          action: \"realTimeCountUpdate\",\n          skippedCount: postsSkippedDuplicateCount,\n          recentAuthorsCount: recentAuthorsDetectedCount,\n          duplicatePostsDetectedCount: duplicatePostsDetectedCount,\n        });\n\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to load commented post URNs from storage\nasync function loadCommentedPostUrns(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([\"commented_post_urns\"], (result) => {\n      const storedUrns = result.commented_post_urns || {};\n      commentedPostUrns = new Map(\n        Object.entries(storedUrns).map(([urn, timestamp]) => [\n          urn,\n          Number(timestamp),\n        ]),\n      );\n      console.log(\n        `Loaded ${commentedPostUrns.size} commented post URNs from storage`,\n      );\n      resolve();\n    });\n  });\n}\n\n// Function to save a commented post URN with timestamp\nasync function saveCommentedPostUrn(urn: string): Promise<void> {\n  const timestamp = Date.now();\n  commentedPostUrns.set(urn, timestamp);\n\n  return new Promise((resolve) => {\n    const urnsObject = Object.fromEntries(commentedPostUrns);\n    chrome.storage.local.set({ commented_post_urns: urnsObject }, () => {\n      console.log(\n        `Saved commented post URN: ${urn} at timestamp: ${timestamp}`,\n      );\n      resolve();\n    });\n  });\n}\n\n// Function to check if we've already commented on a post URN\nfunction hasCommentedOnPostUrn(urn: string): boolean {\n  return commentedPostUrns.has(urn);\n}\n\n// Function to extract post URNs from data-id attribute\nfunction extractPostUrns(postContainer: HTMLElement): string[] {\n  // Look for the top-level div with data-id attribute\n  const topLevelPost = postContainer.closest(\"div[data-id]\") as HTMLElement;\n  if (!topLevelPost) {\n    console.log(\"No div[data-id] found for this post container\");\n    return [];\n  }\n\n  const dataId = topLevelPost.getAttribute(\"data-id\");\n  if (!dataId) {\n    console.log(\"No data-id attribute found\");\n    return [];\n  }\n\n  console.log(`Found data-id: ${dataId}`);\n\n  // Extract URNs - handle both single and aggregate format\n  // Single: \"urn:li:activity:7341086723700936704\"\n  // Aggregate: \"urn:li:aggregate:(urn:li:activity:7341090533815087104,urn:li:activity:7341089862118244355)\"\n  const urns: string[] = [];\n\n  if (dataId.startsWith(\"urn:li:aggregate:\")) {\n    // Handle aggregate format - extract URNs from within parentheses\n    const match = dataId.match(/urn:li:aggregate:\\((.*)\\)/);\n    if (match) {\n      const innerUrns = match[1].split(\",\").map((urn) => urn.trim());\n      urns.push(...innerUrns);\n    }\n  } else if (dataId.startsWith(\"urn:li:activity:\")) {\n    // Handle single activity format\n    urns.push(dataId);\n  }\n\n  console.log(`Extracted URNs: ${urns.join(\", \")}`);\n  return urns;\n}\n\n// Function to update the post already commented counter\nasync function updatePostAlreadyCommentedCounter(): Promise<void> {\n  postsSkippedAlreadyCommentedCount++;\n  duplicatePostsDetectedCount++; // For now, both counters increment together\n\n  return new Promise((resolve) => {\n    chrome.storage.local.set(\n      {\n        postsSkippedAlreadyCommented: postsSkippedAlreadyCommentedCount,\n        duplicatePostsDetected: duplicatePostsDetectedCount,\n      },\n      () => {\n        console.log(\n          `Updated post already commented counter: ${postsSkippedAlreadyCommentedCount}`,\n        );\n        console.log(\n          `Updated duplicate posts detected counter: ${duplicatePostsDetectedCount}`,\n        );\n\n        // Send real-time update to popup\n        chrome.runtime.sendMessage({\n          action: \"realTimeCountUpdate\",\n          postsSkippedAlreadyCommentedCount: postsSkippedAlreadyCommentedCount,\n          duplicatePostsDetectedCount: duplicatePostsDetectedCount,\n        });\n\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to clean up old post URNs (older than 1 year)\nasync function cleanupOldPostUrns(): Promise<void> {\n  const oneYearInMs = 365 * 24 * 60 * 60 * 1000;\n  const now = Date.now();\n\n  return new Promise((resolve) => {\n    let removedCount = 0;\n    const cleanedUrns = new Map<string, number>();\n\n    for (const [urn, timestamp] of commentedPostUrns) {\n      if (now - timestamp < oneYearInMs) {\n        cleanedUrns.set(urn, timestamp);\n      } else {\n        removedCount++;\n      }\n    }\n\n    if (removedCount > 0) {\n      commentedPostUrns = cleanedUrns;\n      const urnsObject = Object.fromEntries(commentedPostUrns);\n      chrome.storage.local.set({ commented_post_urns: urnsObject }, () => {\n        console.log(\n          `Cleaned up ${removedCount} old post URNs (older than 1 year)`,\n        );\n        resolve();\n      });\n    } else {\n      console.log(\"No old post URNs to clean up\");\n      resolve();\n    }\n  });\n}\n\n// Function to update comment counts in local storage\nasync function updateCommentCounts(): Promise<void> {\n  const today = getTodayDateString();\n  const todayKey = `comments_today_${today}`;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([todayKey, \"totalAllTimeComments\"], (result) => {\n      const currentTodayCount = result[todayKey] || 0;\n      const currentAllTimeCount = result[\"totalAllTimeComments\"] || 0;\n\n      const newTodayCount = currentTodayCount + 1;\n      const newAllTimeCount = currentAllTimeCount + 1;\n\n      chrome.storage.local.set(\n        {\n          [todayKey]: newTodayCount,\n          totalAllTimeComments: newAllTimeCount,\n        },\n        () => {\n          console.log(\n            `Updated counts - Today: ${newTodayCount}, All-time: ${newAllTimeCount}`,\n          );\n\n          // Send real-time update to popup\n          chrome.runtime.sendMessage({\n            action: \"realTimeCountUpdate\",\n            todayCount: newTodayCount,\n            allTimeCount: newAllTimeCount,\n          });\n\n          resolve();\n        },\n      );\n    });\n  });\n}\n\n// Main function to start the new commenting flow with delayed tab switching\nasync function startNewCommentingFlowWithDelayedTabSwitch(\n  scrollDuration: number,\n  commentDelay: number,\n  maxPosts: number,\n  styleGuide: string,\n  duplicateWindow: number,\n  overlay: HTMLDivElement,\n  startButton: HTMLButtonElement,\n  subtitle: HTMLParagraphElement,\n  statusPanel: HTMLDivElement,\n) {\n  isCommentingActive = true;\n  console.log(`üöÄ Starting new commenting flow with parameters:`);\n  backgroundLog(`üöÄ Starting new commenting flow with parameters:`);\n  console.log(`   - scrollDuration: ${scrollDuration}`);\n  console.log(`   - commentDelay: ${commentDelay}`);\n  console.log(`   - maxPosts: ${maxPosts}`);\n  console.log(`   - isCommentingActive: ${isCommentingActive}`);\n  backgroundLog(\n    `   - scrollDuration: ${scrollDuration}, commentDelay: ${commentDelay}, maxPosts: ${maxPosts}, isCommentingActive: ${isCommentingActive}`,\n  );\n\n  backgroundLog(\"üé≠ Applied LinkedIn background tab bypass techniques\");\n\n  // // Start anti-throttling mechanisms to prevent tab throttling\n  // keepTabActiveAudio();\n\n  //starts the always active core\n  // window.alwaysActive.enable();\n\n  // Load commented authors with timestamps, post URNs, and counters from local storage\n  commentedAuthorsWithTimestamps = await loadCommentedAuthorsWithTimestamps();\n  await loadCommentedPostUrns();\n  await loadCounters();\n\n  // Clean up old timestamp entries and post URNs to prevent storage bloat\n  await cleanupOldTimestamps();\n  await cleanupOldPostUrns();\n\n  // For backward compatibility, also load today's authors\n  commentedAuthors = await loadTodayCommentedAuthors();\n  console.log(\n    `Loaded ${commentedAuthorsWithTimestamps.size} authors with timestamps and ${commentedAuthors.size} authors for today`,\n  );\n  console.log(\n    `Loaded counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}`,\n  );\n  backgroundLog(\n    `Loaded ${commentedAuthorsWithTimestamps.size} authors with timestamps and ${commentedAuthors.size} authors for today`,\n  );\n  backgroundLog(\n    `Loaded counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}`,\n  );\n\n  try {\n    console.log(`Starting new commenting flow with max ${maxPosts} posts...`);\n    backgroundLog(`Starting new commenting flow with max ${maxPosts} posts...`);\n\n    // Step 1: Scroll down for specified duration to load posts\n    console.log(`üìú Step 1: Scrolling feed for ${scrollDuration} seconds...`);\n    backgroundLog(`üìú Step 1: Scrolling feed for ${scrollDuration} seconds...`);\n    await scrollFeedLoadPosts(scrollDuration, isCommentingActive, statusPanel);\n\n    // IMPORTANT: Only move to original tab AFTER scrolling is completely finished\n    console.log(\n      \"üìú Step 1.5: Scrolling completed, now moving back to original tab...\",\n    );\n    backgroundLog(\n      \"üìú Step 1.5: Scrolling completed, now moving back to original tab...\",\n    );\n    chrome.runtime.sendMessage({\n      action: \"moveToOriginalTab\",\n    });\n\n    // Wait a moment for tab switch to complete\n    await wait(2000);\n\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Commenting stopped during scroll phase\");\n      backgroundLog(\"‚ùå Commenting stopped during scroll phase\");\n      stopTabActiveAudio();\n      return;\n    }\n\n    // Step 2: Scroll back to top\n    console.log(\"üìú Step 2: Scrolling back to top...\");\n    backgroundLog(\"üìú Step 2: Scrolling back to top...\");\n    window.scrollTo({ top: 0, behavior: \"smooth\" });\n    await wait(2000);\n\n    // Update overlay status after scrolling is complete (if overlay elements exist)\n    if (overlay && startButton && subtitle) {\n      startButton.textContent =\n        \"‚úÖ Posts loaded! You can now move away from this tab\";\n      startButton.style.background = \"#28a745\";\n      startButton.style.fontSize = \"20px\";\n      subtitle.textContent =\n        \"All posts have been loaded. Switching to automation mode...\";\n\n      // Wait a moment to show the message, then remove overlay\n      await wait(3000);\n      overlay.remove();\n      backgroundLog(\"üìú üé≠ Overlay removed after successful post loading\");\n    }\n\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Commenting stopped during scroll to top\");\n      backgroundLog(\"‚ùå Commenting stopped during scroll to top\");\n      stopTabActiveAudio();\n      return;\n    }\n\n    // Step 3: Find all posts and process them\n    console.log(\"üìú Step 3: Processing all posts on feed...\");\n    console.log(`   - maxPosts parameter: ${maxPosts}`);\n    console.log(`   - commentDelay parameter: ${commentDelay}`);\n    console.log(\n      `   - isCommentingActive before processing: ${isCommentingActive}`,\n    );\n    backgroundLog(\n      `üìú Step 3: Processing all posts on feed... maxPosts: ${maxPosts}, commentDelay: ${commentDelay}, isCommentingActive: ${isCommentingActive}`,\n    );\n\n    await processAllPostsFeed(commentDelay, maxPosts, duplicateWindow);\n\n    console.log(`üìú Step 3 completed. Final state:`);\n    console.log(`   - isCommentingActive: ${isCommentingActive}`);\n    backgroundLog(\n      `üìú Step 3 completed. Final isCommentingActive: ${isCommentingActive}`,\n    );\n\n    // Stop anti-throttling mechanisms\n    stopTabActiveAudio();\n\n    // Only notify completion if we weren't stopped\n    if (isCommentingActive) {\n      console.log(\"üèÅ Sending completion message to background script...\");\n      backgroundLog(\"üèÅ Sending completion message to background script...\");\n      chrome.runtime.sendMessage({\n        action: \"commentingCompleted\",\n      });\n    } else {\n      console.log(\n        \"üõë Not sending completion message because commenting was stopped\",\n      );\n      backgroundLog(\n        \"üõë Not sending completion message because commenting was stopped\",\n      );\n    }\n  } catch (error) {\n    console.error(\"üí• Error in new commenting flow:\", error);\n    backgroundError(\"üí• Error in new commenting flow:\", error);\n    isCommentingActive = false;\n    stopTabActiveAudio();\n  }\n}\n\n// Function to process all posts on the feed\nasync function processAllPostsFeed(\n  commentDelay: number,\n  maxPosts: number,\n  duplicateWindow: number,\n): Promise<void> {\n  console.group(\"üéØ PROCESSING ALL POSTS - DETAILED DEBUG\");\n  backgroundGroup(\"üéØ PROCESSING ALL POSTS - DETAILED DEBUG\");\n  console.log(\n    `üéØ Starting to process posts on feed (max ${maxPosts} posts)...`,\n  );\n  backgroundLog(\n    `üéØ Starting to process posts on feed (max ${maxPosts} posts)...`,\n  );\n\n  // Find all post containers using the top-level div[data-id] structure\n  const postContainers = document.querySelectorAll(\"div[data-id]\");\n  console.log(\n    `üéØ Found ${postContainers.length} post containers with selector: div[data-id]`,\n  );\n  backgroundLog(\n    `üéØ Found ${postContainers.length} post containers with selector: div[data-id]`,\n  );\n\n  // Let's also try alternative selectors to see what we find\n  const altSelector1 = document.querySelectorAll(\".feed-shared-update-v2\");\n  const altSelector2 = document.querySelectorAll(\n    '[data-urn*=\"urn:li:activity\"]',\n  );\n  const altSelector3 = document.querySelectorAll(\n    \".feed-shared-update-v2__content\",\n  );\n\n  console.log(`üéØ Alternative selector results:`);\n  console.log(`   - .feed-shared-update-v2: ${altSelector1.length} elements`);\n  console.log(\n    `   - [data-urn*=\"urn:li:activity\"]: ${altSelector2.length} elements`,\n  );\n  console.log(\n    `   - .feed-shared-update-v2__content: ${altSelector3.length} elements`,\n  );\n  backgroundLog(\n    `üéØ Alternative selector results: .feed-shared-update-v2: ${altSelector1.length}, [data-urn*=\"urn:li:activity\"]: ${altSelector2.length}, .feed-shared-update-v2__content: ${altSelector3.length}`,\n  );\n\n  if (postContainers.length === 0) {\n    console.error(\n      \"üö® NO POSTS FOUND! This is why the automation stops immediately.\",\n    );\n    console.error(\n      \"üö® The page might not be fully loaded or the selector is wrong.\",\n    );\n    backgroundError(\n      \"üö® NO POSTS FOUND! This is why the automation stops immediately.\",\n    );\n    backgroundError(\n      \"üö® The page might not be fully loaded or the selector is wrong.\",\n    );\n    console.groupEnd();\n    backgroundGroupEnd();\n    return;\n  }\n\n  let commentCount = 0;\n  console.log(\n    `üéØ Starting loop: commentCount=${commentCount}, maxPosts=${maxPosts}, isActive=${isCommentingActive}`,\n  );\n  backgroundLog(\n    `üéØ Starting loop: commentCount=${commentCount}, maxPosts=${maxPosts}, isActive=${isCommentingActive}`,\n  );\n\n  for (\n    let i = 0;\n    i < postContainers.length && isCommentingActive && commentCount < maxPosts;\n    i++\n  ) {\n    console.group(\n      `üîÑ POST ${i + 1}/${postContainers.length} - DETAILED PROCESSING`,\n    );\n    console.log(`üîÑ Loop iteration ${i + 1}:`);\n    console.log(`   - commentCount: ${commentCount}/${maxPosts}`);\n    console.log(`   - isCommentingActive: ${isCommentingActive}`);\n    console.log(\n      `   - Loop condition: i(${i}) < postContainers.length(${\n        postContainers.length\n      }) = ${i < postContainers.length}`,\n    );\n    console.log(\n      `   - Active condition: isCommentingActive = ${isCommentingActive}`,\n    );\n    console.log(\n      `   - Count condition: commentCount(${commentCount}) < maxPosts(${maxPosts}) = ${\n        commentCount < maxPosts\n      }`,\n    );\n    console.log(\n      `   - Overall loop should continue: ${\n        i < postContainers.length &&\n        isCommentingActive &&\n        commentCount < maxPosts\n      }`,\n    );\n\n    // Check if we should stop at the beginning of each iteration\n    if (!isCommentingActive) {\n      console.log(\"‚ùå STOPPING: isCommentingActive became false\");\n      console.groupEnd();\n      break;\n    }\n\n    const postContainer = postContainers[i] as HTMLElement;\n\n    try {\n      console.log(\n        `üîç Processing post ${i + 1}/${\n          postContainers.length\n        } (commented: ${commentCount}/${maxPosts})`,\n      );\n\n      // Scroll to the post\n      postContainer.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n      await wait(1000);\n\n      // Check again after scroll\n      if (!isCommentingActive) {\n        console.log(\n          \"‚ùå STOPPING: isCommentingActive became false after scroll\",\n        );\n        console.groupEnd();\n        break;\n      }\n\n      // STEP 1: Check for post URN duplicates (if we've already commented on this specific post)\n      const postUrns = extractPostUrns(postContainer);\n      if (postUrns.length === 0) {\n        console.log(`‚è≠Ô∏è SKIPPING post ${i + 1} - could not extract post URNs`);\n        console.groupEnd();\n        continue;\n      }\n\n      // Check if we've commented on any of these URNs before\n      let hasCommentedOnThisPost = false;\n      for (const urn of postUrns) {\n        if (hasCommentedOnPostUrn(urn)) {\n          console.log(\n            `‚è≠Ô∏è SKIPPING post ${i + 1} - already commented on post URN: ${urn}`,\n          );\n          hasCommentedOnThisPost = true;\n          break;\n        }\n      }\n\n      if (hasCommentedOnThisPost) {\n        // Update the post already commented counter\n        await updatePostAlreadyCommentedCounter();\n        console.groupEnd();\n        continue;\n      }\n\n      // STEP 2: Check for author duplicate (within time window)\n      const authorInfo = extractAuthorInfo(postContainer);\n      if (!authorInfo) {\n        console.log(\n          `‚è≠Ô∏è SKIPPING post ${i + 1} - could not extract author info`,\n        );\n        console.groupEnd();\n        continue;\n      }\n\n      // Check if we've commented on this author within the time window\n      if (\n        hasCommentedOnAuthorRecently(\n          authorInfo.name,\n          commentedAuthorsWithTimestamps,\n          duplicateWindow,\n        )\n      ) {\n        console.log(\n          `‚è≠Ô∏è SKIPPING post ${i + 1} - already commented on ${\n            authorInfo.name\n          } within ${duplicateWindow} hours`,\n        );\n\n        // Update counters\n        await updateSkippedPostCounter();\n\n        console.groupEnd();\n        continue;\n      }\n\n      // Extract post content\n      const postContent = extractPostContent(postContainer);\n      if (!postContent) {\n        console.log(\n          `‚è≠Ô∏è SKIPPING post ${i + 1} - could not extract post content`,\n        );\n        console.groupEnd();\n        continue;\n      }\n\n      const postAuthorContent = authorInfo.name + postContent;\n\n      console.log(\n        `üìù Post content preview: ${postContent.substring(0, 100)}...`,\n      );\n\n      // Check again before generating comment\n      if (!isCommentingActive) {\n        console.log(\n          \"‚ùå STOPPING: isCommentingActive became false before comment generation\",\n        );\n        console.groupEnd();\n        break;\n      }\n\n      // Generate comment using background script\n      console.log(`ü§ñ Generating comment for post ${i + 1}...`);\n      const comment = await generateComment(postAuthorContent);\n      console.log(\n        `ü§ñ Comment generation result for post ${i + 1}:`,\n        comment ? \"SUCCESS\" : \"FAILED\",\n      );\n\n      if (!comment) {\n        console.log(`‚ùå SKIPPING post ${i + 1} - could not generate comment`);\n        console.groupEnd();\n        continue;\n      }\n\n      console.log(\n        `‚úÖ Generated comment for post ${i + 1}:`,\n        comment.substring(0, 50) + \"...\",\n      );\n\n      // Check again before posting comment\n      if (!isCommentingActive) {\n        console.log(\n          \"‚ùå STOPPING: isCommentingActive became false before posting comment\",\n        );\n        console.groupEnd();\n        break;\n      }\n\n      // Post the comment\n      console.log(\n        `üìù Attempting to post comment on post ${i + 1} by ${\n          authorInfo.name\n        }...`,\n      );\n      const success = await postCommentOnPost(\n        postContainer,\n        comment,\n        isCommentingActive,\n      );\n      console.log(\n        `üìù Comment posting result for post ${i + 1}: ${\n          success ? \"SUCCESS\" : \"FAILED\"\n        }`,\n      );\n\n      if (success) {\n        commentCount++;\n        commentedAuthors.add(authorInfo.name);\n\n        // Save author with timestamp and update counts\n        await saveCommentedAuthor(authorInfo.name); // for backward compatibility\n        await saveCommentedAuthorWithTimestamp(authorInfo.name); // new timestamp-based storage\n        commentedAuthorsWithTimestamps.set(authorInfo.name, Date.now()); // update in-memory data\n\n        // Save all post URNs to prevent commenting on this post again\n        for (const urn of postUrns) {\n          await saveCommentedPostUrn(urn);\n        }\n\n        await updateCommentCounts();\n\n        console.log(\n          `üéâ Successfully posted comment ${commentCount}/${maxPosts} on post by ${authorInfo.name}`,\n        );\n        backgroundLog(\n          `üéâ Successfully posted comment ${commentCount}/${maxPosts} on post by ${authorInfo.name}`,\n        );\n        console.group(`üìä Progress Update After Successful Comment`);\n        console.log(\n          `Comments posted this session: ${commentCount}/${maxPosts}`,\n        );\n        console.log(\n          `Authors commented on today:`,\n          Array.from(commentedAuthors),\n        );\n        console.log(\n          `Remaining posts to process: ${postContainers.length - i - 1}`,\n        );\n        console.log(\n          `Should continue? commentCount(${commentCount}) < maxPosts(${maxPosts}) = ${\n            commentCount < maxPosts\n          }`,\n        );\n        console.log(\n          `Next iteration will be: ${i + 1} < ${postContainers.length} = ${\n            i + 1 < postContainers.length\n          }`,\n        );\n        backgroundLog(\n          `üìä Progress Update: ${commentCount}/${maxPosts} comments posted. Remaining posts: ${\n            postContainers.length - i - 1\n          }. Should continue: ${commentCount < maxPosts}`,\n        );\n        console.groupEnd();\n\n        // Update background script with progress\n        chrome.runtime.sendMessage({\n          action: \"updateCommentCount\",\n          count: commentCount,\n          status: `Posted comment ${commentCount}/${maxPosts} on post by ${authorInfo.name}`,\n        });\n\n        // Check if we've reached the max posts limit\n        if (commentCount >= maxPosts) {\n          console.log(\n            `‚úÖ REACHED MAX POSTS LIMIT: commentCount(${commentCount}) >= maxPosts(${maxPosts}). Stopping...`,\n          );\n          backgroundLog(\n            `‚úÖ REACHED MAX POSTS LIMIT: commentCount(${commentCount}) >= maxPosts(${maxPosts}). Stopping...`,\n          );\n          console.groupEnd();\n          break;\n        }\n\n        // Wait between comments with stop checking\n        if (i < postContainers.length - 1 && commentCount < maxPosts) {\n          console.log(\n            `‚è≥ Waiting ${commentDelay} seconds before next comment...`,\n          );\n          console.log(\n            `‚è≥ Delay conditions: i(${i}) < postContainers.length-1(${\n              postContainers.length - 1\n            }) = ${i < postContainers.length - 1}`,\n          );\n          console.log(\n            `‚è≥ Delay conditions: commentCount(${commentCount}) < maxPosts(${maxPosts}) = ${\n              commentCount < maxPosts\n            }`,\n          );\n\n          // Break the delay into smaller chunks to check for stop signal\n          const delayChunks = Math.ceil(commentDelay);\n          for (\n            let chunk = 0;\n            chunk < delayChunks && isCommentingActive;\n            chunk++\n          ) {\n            await wait(1000);\n            if (!isCommentingActive) {\n              console.log(\n                \"‚ùå STOPPING during comment delay due to stop signal\",\n              );\n              console.groupEnd();\n              break;\n            }\n          }\n\n          if (!isCommentingActive) {\n            console.groupEnd();\n            break;\n          }\n\n          console.log(`‚úÖ Delay completed, continuing to next post...`);\n        } else {\n          console.log(\n            `üîö No delay needed - this was the last post or we've reached max comments`,\n          );\n          console.log(\n            `   - i(${i}) < postContainers.length-1(${\n              postContainers.length - 1\n            }): ${i < postContainers.length - 1}`,\n          );\n          console.log(\n            `   - commentCount(${commentCount}) < maxPosts(${maxPosts}): ${\n              commentCount < maxPosts\n            }`,\n          );\n        }\n      } else {\n        console.log(\n          `‚ùå Failed to post comment on post ${i + 1} by ${authorInfo.name}`,\n        );\n      }\n\n      console.groupEnd();\n    } catch (error) {\n      console.error(`üí• Error processing post ${i + 1}:`, error);\n      console.groupEnd();\n    }\n\n    // Debug the next iteration conditions\n    console.log(`üîÑ End of iteration ${i + 1}. Next iteration check:`);\n    console.log(`   - Next i will be: ${i + 1}`);\n    console.log(`   - postContainers.length: ${postContainers.length}`);\n    console.log(`   - isCommentingActive: ${isCommentingActive}`);\n    console.log(`   - commentCount: ${commentCount}`);\n    console.log(`   - maxPosts: ${maxPosts}`);\n    console.log(\n      `   - Loop will continue: ${\n        i + 1 < postContainers.length &&\n        isCommentingActive &&\n        commentCount < maxPosts\n      }`,\n    );\n  }\n\n  console.log(`üèÅ LOOP COMPLETED. Final stats:`);\n  console.log(`   - Posted ${commentCount}/${maxPosts} comments total`);\n  console.log(`   - Final isCommentingActive: ${isCommentingActive}`);\n  console.log(`   - Processed ${postContainers.length} total posts`);\n  console.log(`   - Loop exit reason analysis:`);\n  console.log(`     - Reached max posts? ${commentCount >= maxPosts}`);\n  console.log(`     - Lost active status? ${!isCommentingActive}`);\n  console.log(`     - Ran out of posts? ${postContainers.length === 0}`);\n  backgroundLog(\n    `üèÅ LOOP COMPLETED. Final stats: Posted ${commentCount}/${maxPosts} comments total. Final isCommentingActive: ${isCommentingActive}. Processed ${postContainers.length} total posts.`,\n  );\n  backgroundLog(\n    `üèÅ Loop exit reason: Reached max posts? ${\n      commentCount >= maxPosts\n    }, Lost active status? ${!isCommentingActive}, Ran out of posts? ${\n      postContainers.length === 0\n    }`,\n  );\n  console.groupEnd();\n  backgroundGroupEnd();\n}\n\n// Function to update time filter skipped counter\nasync function updateTimeFilterSkippedCounter(): Promise<void> {\n  postsSkippedTimeFilterCount++;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.set(\n      {\n        postsSkippedTimeFilter: postsSkippedTimeFilterCount,\n      },\n      () => {\n        console.log(\n          `Updated time filter skipped counter: ${postsSkippedTimeFilterCount}`,\n        );\n\n        // Send real-time update to popup\n        chrome.runtime.sendMessage({\n          action: \"realTimeCountUpdate\",\n          postsSkippedTimeFilterCount: postsSkippedTimeFilterCount,\n        });\n\n        resolve();\n      },\n    );\n  });\n}\n\nfunction stopTabActiveAudio() {\n  try {\n    console.log(\"üîá Stopping continuous audio...\");\n\n    if (currentOscillator) {\n      currentOscillator.stop();\n      currentOscillator = null;\n    }\n\n    if (audioElement) {\n      audioElement.pause();\n      audioElement.remove();\n      audioElement = null;\n    }\n\n    if (audioContext && audioContext.state !== \"closed\") {\n      audioContext.close();\n      audioContext = null;\n    }\n\n    console.log(\"üîá Continuous audio stopped\");\n  } catch (error) {\n    console.warn(\"‚ö†Ô∏è Error stopping audio:\", error);\n  }\n}\n\n// Function to clean up old timestamp entries (older than 7 days)\nasync function cleanupOldTimestamps(): Promise<void> {\n  const storageKey = \"commented_authors_timestamps\";\n  const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;\n  const now = Date.now();\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const authorTimestamps = result[storageKey] || {};\n      const cleanedTimestamps: { [key: string]: number } = {};\n\n      let removedCount = 0;\n      for (const [authorName, timestamp] of Object.entries(authorTimestamps)) {\n        if (typeof timestamp === \"number\" && now - timestamp < sevenDaysInMs) {\n          cleanedTimestamps[authorName] = timestamp;\n        } else {\n          removedCount++;\n        }\n      }\n\n      if (removedCount > 0) {\n        chrome.storage.local.set({ [storageKey]: cleanedTimestamps }, () => {\n          console.log(`Cleaned up ${removedCount} old timestamp entries`);\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nconsole.log(\"EngageKit content script loaded - Background Window Mode\");\n"],"names":["wait","ms","resolve","backgroundLog","args","backgroundError","backgroundGroup","backgroundGroupEnd","extractAuthorInfo","postContainer","authorContainer","nameSelectors","selector","nameElement","name","error","extractPostContent","extractText","node","text","child","_a","contentContainer","content","generateComment","postContent","timeout","attemptGeneration","attempt","response","postCommentOnPost","comment","isCommentingActive","commentButton","commentEditor","editableField","lineText","p","selection","range","inputEvent","submitButton","triggerScrollEvents","scrollEvent","element","wheelEvent","mainContainer","scrollFeedLoadPosts","duration","statusPanel","endTime","scrollAttempts","postCountBefore","lastPostCount","initialPosts","pauseBetweenScrolls","currentTime","timeRemaining","currentPosts","newPostsThisSession","timeRemainingElement","postsLoadedElement","scrollProgressElement","documentHeight","newPostCount","newPosts","totalNewPosts","commentedAuthors","commentedAuthorsWithTimestamps","postsSkippedDuplicateCount","recentAuthorsDetectedCount","commentedPostUrns","postsSkippedAlreadyCommentedCount","duplicatePostsDetectedCount","audioContext","currentOscillator","audioElement","showStartButton","overlay","container","title","subtitle","startButton","infoText","injectAndPlayContinuousSound","result","scrollDuration","commentDelay","maxPosts","duplicateWindow","styleGuide","apiKey","startNewCommentingFlowWithDelayedTabSwitch","reject","AudioContext","oscillator","gainNode","mediaStreamDestination","minFreq","maxFreq","frequency","playPromise","request","sender","sendResponse","stopTabActiveAudio","errorDiv","getTodayDateString","loadCommentedAuthorsWithTimestamps","storageKey","authorTimestamps","timestamp","saveCommentedAuthorWithTimestamp","authorName","now","hasCommentedOnAuthorRecently","hoursWindow","hoursInMs","loadTodayCommentedAuthors","todayAuthors","saveCommentedAuthor","today","loadCounters","updateSkippedPostCounter","loadCommentedPostUrns","storedUrns","urn","saveCommentedPostUrn","urnsObject","hasCommentedOnPostUrn","extractPostUrns","topLevelPost","dataId","urns","match","innerUrns","updatePostAlreadyCommentedCounter","cleanupOldPostUrns","removedCount","cleanedUrns","updateCommentCounts","todayKey","currentTodayCount","currentAllTimeCount","newTodayCount","newAllTimeCount","cleanupOldTimestamps","processAllPostsFeed","postContainers","altSelector1","altSelector2","altSelector3","commentCount","i","postUrns","hasCommentedOnThisPost","authorInfo","postAuthorContent","success","delayChunks","chunk","cleanedTimestamps"],"mappings":"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"}