{"version":3,"file":"index.tsx-wI8QTdav.js","sources":["../../src/pages/content/audio-throttle-service.ts","../../src/pages/content/index.tsx"],"sourcesContent":["export class AudioThrottleService {\n  private audioContext: AudioContext | null = null;\n  private currentOscillator: OscillatorNode | null = null;\n  private audioElement: HTMLAudioElement | null = null;\n\n  public start(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        console.log(\"üéµ Initializing Web Audio API for continuous sound...\");\n\n        // Get the AudioContext constructor, working across browsers\n        const AudioContext =\n          window.AudioContext || (window as any).webkitAudioContext;\n\n        // Check if Web Audio API is supported\n        if (!AudioContext) {\n          throw new Error(\n            \"Web Audio API is not supported in this browser. Cannot play audio.\",\n          );\n        }\n\n        // Create an AudioContext instance\n        // This is the gateway to using the Web Audio API\n        this.audioContext = new AudioContext();\n\n        // --- Sound Generation Setup ---\n\n        // Create an OscillatorNode: This will generate the actual sound wave\n        const oscillator = this.audioContext.createOscillator();\n\n        // Create a GainNode: This will control the volume of the sound\n        const gainNode = this.audioContext.createGain();\n\n        // Create a MediaStreamDestinationNode: This allows us to take the audio\n        // generated by the Web Audio API and use it as a source for an HTML <audio> element.\n        const mediaStreamDestination =\n          this.audioContext.createMediaStreamDestination();\n\n        // Connect the nodes: Oscillator -> GainNode -> MediaStreamDestination\n        // The sound flows from the oscillator, through the volume control (gain),\n        // and then to the stream destination.\n        oscillator.connect(gainNode);\n        gainNode.connect(mediaStreamDestination);\n\n        // --- Configure the Sound ---\n\n        // Set the type of wave for the oscillator\n        // 'sine': a pure, smooth tone\n        // Other options: 'square', 'sawtooth', 'triangle'\n        oscillator.type = \"sine\";\n\n        // Set the frequency (pitch) of the sound in Hertz (Hz)\n        // Let's pick a random frequency in a generally pleasant mid-range (e.g., between C4 and C5)\n        // C4 is approx 261.63 Hz, C5 is approx 523.25 Hz\n        const minFreq = 261.63;\n        const maxFreq = 523.25;\n        // const frequency = Math.random() * (maxFreq - minFreq) + minFreq;\n        const frequency = 10000;\n\n        //picking an inaudible frequency almost zero volume\n        oscillator.frequency.setValueAtTime(\n          frequency,\n          this.audioContext.currentTime,\n        );\n\n        // Set the volume using the GainNode\n        // 0.0 is silent, 1.0 is full volume. Let's set it low to be less intrusive.\n        gainNode.gain.setValueAtTime(0.001, this.audioContext.currentTime); // 10% volume\n\n        // --- HTML <audio> Element Setup ---\n\n        // Create a new HTML <audio> element\n        this.audioElement = document.createElement(\"audio\");\n\n        // Set the source of the audio element to the stream from our Web Audio API setup\n        this.audioElement.srcObject = mediaStreamDestination.stream;\n\n        // Set the audio to autoplay\n        // IMPORTANT: Browsers have autoplay restrictions. This might not work without user interaction.\n        this.audioElement.autoplay = true;\n\n        // Set the audio to loop continuously\n        this.audioElement.loop = true;\n\n        // Hide the default audio controls for background audio\n        this.audioElement.controls = false;\n\n        // Hide the audio element\n        this.audioElement.style.cssText =\n          \"position: fixed; top: -9999px; opacity: 0;\";\n\n        // --- Inject into DOM and Start ---\n\n        // Append the new audio element to the body of the document\n        // This makes it part of the webpage\n        document.body.appendChild(this.audioElement);\n\n        // Resume AudioContext if needed (for user gesture compliance)\n        const startAudioPlayback = async () => {\n          if (this.audioContext!.state === \"suspended\") {\n            await this.audioContext!.resume();\n          }\n\n          // Start the oscillator to begin generating sound\n          // This needs to happen for any sound to be produced\n          oscillator.start();\n          this.currentOscillator = oscillator;\n\n          // Attempt to play the HTML audio element\n          // This is often needed due to autoplay policies, especially if audioCtx was not started by user gesture.\n          const playPromise = this.audioElement!.play();\n\n          if (playPromise !== undefined) {\n            playPromise\n              .then(() => {\n                // Autoplay started successfully.\n                console.log(\n                  `‚úÖ Playing a ${oscillator.type} wave at ${frequency.toFixed(\n                    2,\n                  )} Hz. Audio element injected and playing.`,\n                );\n                resolve();\n              })\n              .catch((error) => {\n                // Autoplay was prevented.\n                console.warn(\n                  \"‚ùå Autoplay was prevented by the browser:\",\n                  error,\n                );\n                reject(error);\n              });\n          } else {\n            console.log(`‚úÖ Audio started successfully (no promise returned)`);\n            resolve();\n          }\n        };\n\n        startAudioPlayback();\n      } catch (error) {\n        console.error(\"‚ùå Audio setup failed:\", error);\n        reject(error);\n      }\n    });\n  }\n\n  public stop(): void {\n    try {\n      console.log(\"üîá Stopping continuous audio...\");\n\n      if (this.currentOscillator) {\n        this.currentOscillator.stop();\n        this.currentOscillator = null;\n      }\n\n      if (this.audioElement) {\n        this.audioElement.pause();\n        this.audioElement.remove();\n        this.audioElement = null;\n      }\n\n      if (this.audioContext && this.audioContext.state !== \"closed\") {\n        this.audioContext.close();\n        this.audioContext = null;\n      }\n\n      console.log(\"üîá Continuous audio stopped\");\n    } catch (error) {\n      console.warn(\"‚ö†Ô∏è Error stopping audio:\", error);\n    }\n  }\n}\n","import { AudioThrottleService } from \"./audio-throttle-service\";\nimport {\n  backgroundError,\n  backgroundGroup,\n  backgroundGroupEnd,\n  backgroundLog,\n  backgroundWarn,\n} from \"./background-log\";\n\n// Content script for EngageKit - Background Window Mode\n// This script processes posts directly on the feed page\n\nlet isCommentingActive = false;\nlet commentedAuthors = new Set<string>();\nlet commentedAuthorsWithTimestamps = new Map<string, number>();\nlet postsSkippedDuplicateCount = 0;\nlet recentAuthorsDetectedCount = 0;\nlet commentedPostUrns = new Map<string, number>(); // URN -> timestamp\nlet postsSkippedAlreadyCommentedCount = 0;\nlet duplicatePostsDetectedCount = 0;\nlet postsSkippedTimeFilterCount = 0;\n\nconst audioService = new AudioThrottleService();\n\n// Check if we need to show the start button\nlet hasUserInteracted = false;\n\n//check if page is ready to display the start button\nif (document.readyState !== \"loading\") {\n  console.log(\"document is already ready, just execute code here\");\n  //send page ready message to background script\n  chrome.runtime.sendMessage({\n    action: \"pageReady\",\n  });\n} else {\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    console.log(\"document was not ready, place code here\");\n    //send page ready message to background script\n    chrome.runtime.sendMessage({\n      action: \"pageReady\",\n    });\n  });\n}\n\n// Function to show the start button overlay\nfunction showStartButton() {\n  console.log(\"üöÄ Showing start button for EngageKit...\");\n\n  // Don't show multiple buttons\n  if (document.getElementById(\"linkedin-start-overlay\")) {\n    return;\n  }\n\n  // Create full-screen overlay\n  const overlay = document.createElement(\"div\");\n  overlay.id = \"linkedin-start-overlay\";\n  overlay.style.cssText = `\n    position: fixed !important;\n    top: 0 !important;\n    left: 0 !important;\n    width: 100vw !important;\n    height: 100vh !important;\n    background: rgba(0, 115, 177, 0.95) !important;\n    z-index: 2147483647 !important;\n    display: flex !important;\n    flex-direction: column !important;\n    justify-content: center !important;\n    align-items: center !important;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif !important;\n    color: white !important;\n  `;\n\n  // Create container\n  const container = document.createElement(\"div\");\n  container.style.cssText = `\n    text-align: center !important;\n    max-width: 600px !important;\n    padding: 40px !important;\n    background: rgba(255, 255, 255, 0.1) !important;\n    border-radius: 20px !important;\n    backdrop-filter: blur(10px) !important;\n  `;\n\n  // Create title\n  const title = document.createElement(\"h1\");\n  title.textContent = \"EngageKit\";\n  title.style.cssText = `\n    font-size: 48px !important;\n    margin: 0 0 20px 0 !important;\n    text-align: center !important;\n    font-weight: bold !important;\n    color: white !important;\n  `;\n\n  // Create subtitle\n  const subtitle = document.createElement(\"p\");\n  subtitle.textContent = \"Click to start auto-commenting on LinkedIn posts\";\n  subtitle.style.cssText = `\n    font-size: 20px !important;\n    margin: 0 0 40px 0 !important;\n    text-align: center !important;\n    opacity: 0.9 !important;\n    color: white !important;\n  `;\n\n  // Create start button\n  const startButton = document.createElement(\"button\");\n  startButton.textContent = \"üöÄ Start Auto-Commenting\";\n  startButton.style.cssText = `\n    background: #ffffff !important;\n    color: #0073b1 !important;\n    border: none !important;\n    padding: 20px 40px !important;\n    font-size: 24px !important;\n    font-weight: bold !important;\n    border-radius: 12px !important;\n    cursor: pointer !important;\n    box-shadow: 0 8px 16px rgba(0,0,0,0.2) !important;\n    transition: all 0.3s ease !important;\n    margin: 0 0 20px 0 !important;\n    font-family: inherit !important;\n  `;\n\n  // Add hover effects\n  startButton.addEventListener(\"mouseenter\", () => {\n    startButton.style.transform = \"translateY(-2px)\";\n    startButton.style.boxShadow = \"0 12px 20px rgba(0,0,0,0.3)\";\n  });\n\n  startButton.addEventListener(\"mouseleave\", () => {\n    startButton.style.transform = \"translateY(0)\";\n    startButton.style.boxShadow = \"0 8px 16px rgba(0,0,0,0.2)\";\n  });\n\n  // Create info text\n  const infoText = document.createElement(\"p\");\n  infoText.innerHTML = `\n    <strong>What will happen:</strong><br>\n    ‚Ä¢ Audio will start playing to keep this tab active<br>\n    ‚Ä¢ This window will move to the background<br>\n    ‚Ä¢ Auto-commenting will begin immediately<br>\n    ‚Ä¢ You can continue using other applications\n  `;\n  infoText.style.cssText = `\n    font-size: 16px !important;\n    text-align: center !important;\n    opacity: 0.8 !important;\n    line-height: 1.6 !important;\n    max-width: 500px !important;\n    margin: 0 !important;\n    color: white !important;\n  `;\n\n  // Button click handler\n  startButton.addEventListener(\"click\", async () => {\n    console.log(\"üöÄ Start button clicked! Beginning full flow...\");\n    hasUserInteracted = true;\n\n    // Update button state\n    startButton.textContent = \"üîÑ Starting...\";\n    startButton.style.background = \"#28a745\";\n    startButton.style.color = \"white\";\n    startButton.disabled = true;\n\n    try {\n      // Step 1: Start continuous audio\n      console.log(\"üéµ Step 1: Starting continuous audio...\");\n      await audioService.start();\n\n      startButton.textContent = \"üéµ Audio Started\";\n\n      await wait(1000);\n      startButton.textContent = \"üí¨ Starting flow\";\n      //step 2: move back to the original tab\n\n      // Get settings from storage and start commenting\n      chrome.storage.local.get(\n        [\n          \"scrollDuration\",\n          \"commentDelay\",\n          \"maxPosts\",\n          \"duplicateWindow\",\n          \"styleGuide\",\n          \"apiKey\",\n        ],\n        (result) => {\n          backgroundLog(\"Content: Retrieved settings from storage:\", result);\n\n          // Use popup settings with fallbacks only if completely missing\n          const scrollDuration =\n            result.scrollDuration !== undefined ? result.scrollDuration : 10;\n          const commentDelay =\n            result.commentDelay !== undefined ? result.commentDelay : 5;\n          const maxPosts = result.maxPosts !== undefined ? result.maxPosts : 5;\n          const duplicateWindow =\n            result.duplicateWindow !== undefined ? result.duplicateWindow : 24;\n          const styleGuide =\n            result.styleGuide !== undefined\n              ? result.styleGuide\n              : \"Be engaging and professional\";\n          const apiKey = result.apiKey !== undefined ? result.apiKey : \"\";\n\n          backgroundLog(\"üéØ Starting commenting flow with settings:\", {\n            scrollDuration,\n            commentDelay,\n            maxPosts,\n            styleGuide: styleGuide?.substring(0, 50) + \"...\",\n            hasApiKey: !!apiKey,\n          });\n\n          // API key check removed - using server-side tRPC API now\n\n          if (!styleGuide) {\n            backgroundError(\n              \"‚ùå No style guide found in storage! Cannot start commenting.\",\n            );\n            return;\n          }\n\n          // Update button status for scrolling phase\n          startButton.textContent = `üìú Scrolling to load posts (${scrollDuration}s) - DON'T navigate away!`;\n          startButton.style.background = \"#ff9500\";\n          startButton.style.fontSize = \"18px\";\n          subtitle.textContent =\n            \"Loading posts from LinkedIn feed - please keep this tab visible\";\n\n          // Add dynamic status panel to the overlay\n          const statusPanel = document.createElement(\"div\");\n          statusPanel.id = \"linkedin-status-panel\";\n          statusPanel.style.cssText = `\n          background: rgba(255, 255, 255, 0.15) !important;\n          border-radius: 12px !important;\n          padding: 20px !important;\n          margin-top: 20px !important;\n          border: 1px solid rgba(255, 255, 255, 0.3) !important;\n          font-family: monospace !important;\n          font-size: 14px !important;\n          line-height: 1.6 !important;\n        `;\n\n          const initialPosts = document.querySelectorAll(\n            \".feed-shared-update-v2__control-menu-container\",\n          ).length;\n\n          statusPanel.innerHTML = `\n          <div style=\"color: white !important; margin-bottom: 12px !important;\">\n            <strong>üìä AUTOMATION SETTINGS</strong>\n          </div>\n          <div style=\"color: #e0e0e0 !important; margin-bottom: 8px !important;\">\n            üìú Scroll Duration: <span style=\"color: #90EE90 !important;\">${scrollDuration} seconds</span>\n          </div>\n          <div style=\"color: #e0e0e0 !important; margin-bottom: 8px !important;\">\n            ‚è±Ô∏è Comment Delay: <span style=\"color: #90EE90 !important;\">${commentDelay} seconds</span>\n          </div>\n          <div style=\"color: #e0e0e0 !important; margin-bottom: 16px !important;\">\n            üéØ Max Posts: <span style=\"color: #90EE90 !important;\">${maxPosts} posts</span>\n          </div>\n          \n          <div style=\"color: white !important; margin-bottom: 12px !important;\">\n            <strong>üìà REAL-TIME STATUS</strong>\n          </div>\n          <div id=\"time-remaining\" style=\"color: #FFD700 !important; margin-bottom: 8px !important;\">\n            ‚è∞ Time Remaining: <span style=\"color: #FFA500 !important;\">${scrollDuration}s</span>\n          </div>\n          <div id=\"posts-loaded\" style=\"color: #87CEEB !important; margin-bottom: 8px !important;\">\n            üìù Posts Loaded: <span style=\"color: #00BFFF !important;\">${initialPosts} posts</span>\n          </div>\n          <div id=\"scroll-progress\" style=\"color: #DDA0DD !important;\">\n            üîÑ Status: <span style=\"color: #DA70D6 !important;\">Starting scroll...</span>\n          </div>\n        `;\n\n          // Add status panel to the container (after the info text)\n          const container = overlay.querySelector(\"div\");\n          if (container) {\n            container.appendChild(statusPanel);\n          }\n\n          // Start the commenting flow but delay tab switching until after scrolling\n          startNewCommentingFlowWithDelayedTabSwitch(\n            scrollDuration,\n            commentDelay,\n            maxPosts,\n            styleGuide,\n            duplicateWindow,\n            overlay,\n            startButton,\n            subtitle,\n            statusPanel,\n          );\n        },\n      );\n\n      // Don't remove overlay here - let the commenting flow handle it\n\n      console.log(\"‚úÖ Full flow started successfully!\");\n    } catch (error) {\n      console.error(\"‚ùå Failed to start:\", error);\n      startButton.textContent = \"‚ùå Failed - Try Again\";\n      startButton.style.background = \"#dc3545\";\n      startButton.disabled = false;\n      subtitle.textContent = \"Something went wrong - click to try again\";\n    }\n  });\n\n  // Assemble UI\n  container.appendChild(title);\n  container.appendChild(subtitle);\n  container.appendChild(startButton);\n  container.appendChild(infoText);\n  overlay.appendChild(container);\n\n  // Add to page\n  document.body.appendChild(overlay);\n\n  console.log(\"üöÄ Start button overlay displayed\");\n}\n\n// --- Main function to create and play the continuous audio ---\n// This has been moved to audio-throttle-service.ts\n\n// Listen for messages from the background script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.action === \"startCommentingFlow\") {\n    console.log(\"Received start signal - starting commenting flow\");\n    isCommentingActive = true;\n    sendResponse({ success: true });\n  } else if (request.action === \"stopCommentingFlow\") {\n    console.log(\"Received stop signal - stopping commenting flow\");\n    isCommentingActive = false;\n    audioService.stop();\n    sendResponse({ success: true });\n  } else if (request.action === \"openrouter_error\") {\n    // Handle OpenRouter API errors specifically\n    // ... existing code ...\n  }\n});\n\n// Function to get today's date string\nfunction getTodayDateString(): string {\n  return new Date().toDateString();\n}\n\n// Function to load commented authors with timestamps from local storage\nasync function loadCommentedAuthorsWithTimestamps(): Promise<\n  Map<string, number>\n> {\n  const storageKey = \"commented_authors_timestamps\";\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const authorTimestamps = result[storageKey] || {};\n      resolve(\n        new Map(\n          Object.entries(authorTimestamps).map(([name, timestamp]) => [\n            name,\n            Number(timestamp),\n          ]),\n        ),\n      );\n    });\n  });\n}\n\n// Function to save commented author with timestamp to local storage\nasync function saveCommentedAuthorWithTimestamp(\n  authorName: string,\n): Promise<void> {\n  const storageKey = \"commented_authors_timestamps\";\n  const now = Date.now();\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const authorTimestamps = result[storageKey] || {};\n      authorTimestamps[authorName] = now;\n      chrome.storage.local.set({ [storageKey]: authorTimestamps }, () => {\n        console.log(\n          `Saved commented author: ${authorName} at timestamp: ${now}`,\n        );\n        resolve();\n      });\n    });\n  });\n}\n\n// Function to check if author was commented on within the specified time window\nfunction hasCommentedOnAuthorRecently(\n  authorName: string,\n  commentedAuthors: Map<string, number>,\n  hoursWindow: number,\n): boolean {\n  const timestamp = commentedAuthors.get(authorName);\n  if (!timestamp) return false;\n\n  const now = Date.now();\n  const hoursInMs = hoursWindow * 60 * 60 * 1000;\n\n  return now - timestamp < hoursInMs;\n}\n\n// Function to load today's commented authors from local storage (for backward compatibility)\nasync function loadTodayCommentedAuthors(): Promise<Set<string>> {\n  const today = getTodayDateString();\n  const storageKey = `commented_authors_${today}`;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const todayAuthors = result[storageKey] || [];\n      resolve(new Set(todayAuthors));\n    });\n  });\n}\n\n// Function to save commented author to local storage (for backward compatibility)\nasync function saveCommentedAuthor(authorName: string): Promise<void> {\n  const today = getTodayDateString();\n  const storageKey = `commented_authors_${today}`;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const todayAuthors = result[storageKey] || [];\n      if (!todayAuthors.includes(authorName)) {\n        todayAuthors.push(authorName);\n        chrome.storage.local.set({ [storageKey]: todayAuthors }, () => {\n          console.log(`Saved commented author: ${authorName} for ${today}`);\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n// Function to load counter values from storage\nasync function loadCounters(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(\n      [\n        \"postsSkippedDuplicate\",\n        \"recentAuthorsDetected\",\n        \"postsSkippedAlreadyCommented\",\n        \"duplicatePostsDetected\",\n      ],\n      (result) => {\n        postsSkippedDuplicateCount = result.postsSkippedDuplicate || 0;\n        recentAuthorsDetectedCount = result.recentAuthorsDetected || 0;\n        postsSkippedAlreadyCommentedCount =\n          result.postsSkippedAlreadyCommented || 0;\n        duplicatePostsDetectedCount = result.duplicatePostsDetected || 0;\n        console.log(\n          `Loaded counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}, Posts already commented: ${postsSkippedAlreadyCommentedCount}, Duplicate posts detected: ${duplicatePostsDetectedCount}`,\n        );\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to update skipped post counter\nasync function updateSkippedPostCounter(): Promise<void> {\n  postsSkippedDuplicateCount++;\n  recentAuthorsDetectedCount++; // For now both counters increment together\n  duplicatePostsDetectedCount++; // For now, both author filter skips and post URN skips increment this\n\n  return new Promise((resolve) => {\n    chrome.storage.local.set(\n      {\n        postsSkippedDuplicate: postsSkippedDuplicateCount,\n        recentAuthorsDetected: recentAuthorsDetectedCount,\n        duplicatePostsDetected: duplicatePostsDetectedCount,\n      },\n      () => {\n        console.log(\n          `Updated counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}, Duplicate posts detected: ${duplicatePostsDetectedCount}`,\n        );\n\n        // Send real-time update to popup\n        chrome.runtime.sendMessage({\n          action: \"realTimeCountUpdate\",\n          skippedCount: postsSkippedDuplicateCount,\n          recentAuthorsCount: recentAuthorsDetectedCount,\n          duplicatePostsDetectedCount: duplicatePostsDetectedCount,\n        });\n\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to load commented post URNs from storage\nasync function loadCommentedPostUrns(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([\"commented_post_urns\"], (result) => {\n      const storedUrns = result.commented_post_urns || {};\n      commentedPostUrns = new Map(\n        Object.entries(storedUrns).map(([urn, timestamp]) => [\n          urn,\n          Number(timestamp),\n        ]),\n      );\n      console.log(\n        `Loaded ${commentedPostUrns.size} commented post URNs from storage`,\n      );\n      resolve();\n    });\n  });\n}\n\n// Function to save a commented post URN with timestamp\nasync function saveCommentedPostUrn(urn: string): Promise<void> {\n  const timestamp = Date.now();\n  commentedPostUrns.set(urn, timestamp);\n\n  return new Promise((resolve) => {\n    const urnsObject = Object.fromEntries(commentedPostUrns);\n    chrome.storage.local.set({ commented_post_urns: urnsObject }, () => {\n      console.log(\n        `Saved commented post URN: ${urn} at timestamp: ${timestamp}`,\n      );\n      resolve();\n    });\n  });\n}\n\n// Function to check if we've already commented on a post URN\nfunction hasCommentedOnPostUrn(urn: string): boolean {\n  return commentedPostUrns.has(urn);\n}\n\n// Function to extract post URNs from data-id attribute\nfunction extractPostUrns(postContainer: HTMLElement): string[] {\n  // Look for the top-level div with data-id attribute\n  const topLevelPost = postContainer.closest(\"div[data-id]\") as HTMLElement;\n  if (!topLevelPost) {\n    console.log(\"No div[data-id] found for this post container\");\n    return [];\n  }\n\n  const dataId = topLevelPost.getAttribute(\"data-id\");\n  if (!dataId) {\n    console.log(\"No data-id attribute found\");\n    return [];\n  }\n\n  console.log(`Found data-id: ${dataId}`);\n\n  // Extract URNs - handle both single and aggregate format\n  // Single: \"urn:li:activity:7341086723700936704\"\n  // Aggregate: \"urn:li:aggregate:(urn:li:activity:7341090533815087104,urn:li:activity:7341089862118244355)\"\n  const urns: string[] = [];\n\n  if (dataId.startsWith(\"urn:li:aggregate:\")) {\n    // Handle aggregate format - extract URNs from within parentheses\n    const match = dataId.match(/urn:li:aggregate:\\((.*)\\)/);\n    if (match) {\n      const innerUrns = match[1].split(\",\").map((urn) => urn.trim());\n      urns.push(...innerUrns);\n    }\n  } else if (dataId.startsWith(\"urn:li:activity:\")) {\n    // Handle single activity format\n    urns.push(dataId);\n  }\n\n  console.log(`Extracted URNs: ${urns.join(\", \")}`);\n  return urns;\n}\n\n// Function to update the post already commented counter\nasync function updatePostAlreadyCommentedCounter(): Promise<void> {\n  postsSkippedAlreadyCommentedCount++;\n  duplicatePostsDetectedCount++; // For now, both counters increment together\n\n  return new Promise((resolve) => {\n    chrome.storage.local.set(\n      {\n        postsSkippedAlreadyCommented: postsSkippedAlreadyCommentedCount,\n        duplicatePostsDetected: duplicatePostsDetectedCount,\n      },\n      () => {\n        console.log(\n          `Updated post already commented counter: ${postsSkippedAlreadyCommentedCount}`,\n        );\n        console.log(\n          `Updated duplicate posts detected counter: ${duplicatePostsDetectedCount}`,\n        );\n\n        // Send real-time update to popup\n        chrome.runtime.sendMessage({\n          action: \"realTimeCountUpdate\",\n          postsSkippedAlreadyCommentedCount: postsSkippedAlreadyCommentedCount,\n          duplicatePostsDetectedCount: duplicatePostsDetectedCount,\n        });\n\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to clean up old post URNs (older than 1 year)\nasync function cleanupOldPostUrns(): Promise<void> {\n  const oneYearInMs = 365 * 24 * 60 * 60 * 1000;\n  const now = Date.now();\n\n  return new Promise((resolve) => {\n    let removedCount = 0;\n    const cleanedUrns = new Map<string, number>();\n\n    for (const [urn, timestamp] of commentedPostUrns) {\n      if (now - timestamp < oneYearInMs) {\n        cleanedUrns.set(urn, timestamp);\n      } else {\n        removedCount++;\n      }\n    }\n\n    if (removedCount > 0) {\n      commentedPostUrns = cleanedUrns;\n      const urnsObject = Object.fromEntries(commentedPostUrns);\n      chrome.storage.local.set({ commented_post_urns: urnsObject }, () => {\n        console.log(\n          `Cleaned up ${removedCount} old post URNs (older than 1 year)`,\n        );\n        resolve();\n      });\n    } else {\n      console.log(\"No old post URNs to clean up\");\n      resolve();\n    }\n  });\n}\n\n// Function to update comment counts in local storage\nasync function updateCommentCounts(): Promise<void> {\n  const today = getTodayDateString();\n  const todayKey = `comments_today_${today}`;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([todayKey, \"totalAllTimeComments\"], (result) => {\n      const currentTodayCount = result[todayKey] || 0;\n      const currentAllTimeCount = result[\"totalAllTimeComments\"] || 0;\n\n      const newTodayCount = currentTodayCount + 1;\n      const newAllTimeCount = currentAllTimeCount + 1;\n\n      chrome.storage.local.set(\n        {\n          [todayKey]: newTodayCount,\n          totalAllTimeComments: newAllTimeCount,\n        },\n        () => {\n          console.log(\n            `Updated counts - Today: ${newTodayCount}, All-time: ${newAllTimeCount}`,\n          );\n\n          // Send real-time update to popup\n          chrome.runtime.sendMessage({\n            action: \"realTimeCountUpdate\",\n            todayCount: newTodayCount,\n            allTimeCount: newAllTimeCount,\n          });\n\n          resolve();\n        },\n      );\n    });\n  });\n}\n\n// Main function to start the new commenting flow with delayed tab switching\nasync function startNewCommentingFlowWithDelayedTabSwitch(\n  scrollDuration: number,\n  commentDelay: number,\n  maxPosts: number,\n  styleGuide: string,\n  duplicateWindow: number,\n  overlay: HTMLDivElement,\n  startButton: HTMLButtonElement,\n  subtitle: HTMLParagraphElement,\n  statusPanel: HTMLDivElement,\n) {\n  isCommentingActive = true;\n  console.log(`üöÄ Starting new commenting flow with parameters:`);\n  backgroundLog(`üöÄ Starting new commenting flow with parameters:`);\n  console.log(`   - scrollDuration: ${scrollDuration}`);\n  console.log(`   - commentDelay: ${commentDelay}`);\n  console.log(`   - maxPosts: ${maxPosts}`);\n  console.log(`   - isCommentingActive: ${isCommentingActive}`);\n  backgroundLog(\n    `   - scrollDuration: ${scrollDuration}, commentDelay: ${commentDelay}, maxPosts: ${maxPosts}, isCommentingActive: ${isCommentingActive}`,\n  );\n\n  // Apply tab active state spoofing immediately to prevent LinkedIn from detecting background tab\n  await forceTabActiveState();\n  backgroundLog(\"üé≠ Applied LinkedIn background tab bypass techniques\");\n\n  // // Start anti-throttling mechanisms to prevent tab throttling\n  // keepTabActiveAudio();\n\n  //starts the always active core\n  // window.alwaysActive.enable();\n\n  // Load commented authors with timestamps, post URNs, and counters from local storage\n  commentedAuthorsWithTimestamps = await loadCommentedAuthorsWithTimestamps();\n  await loadCommentedPostUrns();\n  await loadCounters();\n\n  // Clean up old timestamp entries and post URNs to prevent storage bloat\n  await cleanupOldTimestamps();\n  await cleanupOldPostUrns();\n\n  // For backward compatibility, also load today's authors\n  commentedAuthors = await loadTodayCommentedAuthors();\n  console.log(\n    `Loaded ${commentedAuthorsWithTimestamps.size} authors with timestamps and ${commentedAuthors.size} authors for today`,\n  );\n  console.log(\n    `Loaded counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}`,\n  );\n  backgroundLog(\n    `Loaded ${commentedAuthorsWithTimestamps.size} authors with timestamps and ${commentedAuthors.size} authors for today`,\n  );\n  backgroundLog(\n    `Loaded counters - Posts skipped: ${postsSkippedDuplicateCount}, Recent authors: ${recentAuthorsDetectedCount}`,\n  );\n\n  try {\n    console.log(`Starting new commenting flow with max ${maxPosts} posts...`);\n    backgroundLog(`Starting new commenting flow with max ${maxPosts} posts...`);\n\n    // Step 1: Scroll down for specified duration to load posts\n    console.log(`üìú Step 1: Scrolling feed for ${scrollDuration} seconds...`);\n    backgroundLog(`üìú Step 1: Scrolling feed for ${scrollDuration} seconds...`);\n    await scrollFeedToLoadPosts(scrollDuration, statusPanel);\n\n    // IMPORTANT: Only move to original tab AFTER scrolling is completely finished\n    console.log(\n      \"üìú Step 1.5: Scrolling completed, now moving back to original tab...\",\n    );\n    backgroundLog(\n      \"üìú Step 1.5: Scrolling completed, now moving back to original tab...\",\n    );\n    chrome.runtime.sendMessage({\n      action: \"moveToOriginalTab\",\n    });\n\n    // Wait a moment for tab switch to complete\n    await wait(2000);\n\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Commenting stopped during scroll phase\");\n      backgroundLog(\"‚ùå Commenting stopped during scroll phase\");\n      audioService.stop();\n      return;\n    }\n\n    // Step 2: Scroll back to top\n    console.log(\"üìú Step 2: Scrolling back to top...\");\n    backgroundLog(\"üìú Step 2: Scrolling back to top...\");\n    window.scrollTo({ top: 0, behavior: \"smooth\" });\n    await wait(2000);\n\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Commenting stopped during scroll to top\");\n      backgroundLog(\"‚ùå Commenting stopped during scroll to top\");\n      audioService.stop();\n      return;\n    }\n\n    // Update overlay status after scrolling is complete (if overlay elements exist)\n    if (overlay && startButton && subtitle) {\n      startButton.textContent =\n        \"‚úÖ Posts loaded! You can now move away from this tab\";\n      startButton.style.background = \"#28a745\";\n      startButton.style.fontSize = \"20px\";\n      subtitle.textContent =\n        \"All posts have been loaded. Switching to automation mode...\";\n\n      // Wait a moment to show the message, then remove overlay\n      await wait(3000);\n      overlay.remove();\n      backgroundLog(\"üìú üé≠ Overlay removed after successful post loading\");\n    }\n\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Commenting stopped during scroll to top\");\n      backgroundLog(\"‚ùå Commenting stopped during scroll to top\");\n      audioService.stop();\n      return;\n    }\n\n    // Step 3: Find all posts and process them\n    console.log(\"üìú Step 3: Processing all posts on feed...\");\n    console.log(`   - maxPosts parameter: ${maxPosts}`);\n    console.log(`   - commentDelay parameter: ${commentDelay}`);\n    console.log(\n      `   - isCommentingActive before processing: ${isCommentingActive}`,\n    );\n    backgroundLog(\n      `üìú Step 3: Processing all posts on feed... maxPosts: ${maxPosts}, commentDelay: ${commentDelay}, isCommentingActive: ${isCommentingActive}`,\n    );\n\n    await processAllPostsOnFeed(commentDelay, maxPosts, duplicateWindow);\n\n    console.log(`üìú Step 3 completed. Final state:`);\n    console.log(`   - isCommentingActive: ${isCommentingActive}`);\n    backgroundLog(\n      `üìú Step 3 completed. Final isCommentingActive: ${isCommentingActive}`,\n    );\n\n    // Stop anti-throttling mechanisms\n    audioService.stop();\n\n    // Only notify completion if we weren't stopped\n    if (isCommentingActive) {\n      console.log(\"üèÅ Sending completion message to background script...\");\n      backgroundLog(\"üèÅ Sending completion message to background script...\");\n      chrome.runtime.sendMessage({\n        action: \"commentingCompleted\",\n      });\n    } else {\n      console.log(\n        \"üõë Not sending completion message because commenting was stopped\",\n      );\n      backgroundLog(\n        \"üõë Not sending completion message because commenting was stopped\",\n      );\n    }\n  } catch (error) {\n    console.error(\"üí• Error in new commenting flow:\", error);\n    backgroundError(\"üí• Error in new commenting flow:\", error);\n    isCommentingActive = false;\n    audioService.stop();\n  }\n}\n\n// Helper function to request notification permission for anti-throttling\nasync function requestNotificationPermissionForAntiThrottling(): Promise<boolean> {\n  try {\n    if (!(\"Notification\" in window)) {\n      backgroundLog(\"üìú üîî Notifications not supported in this browser\");\n      return false;\n    }\n\n    if (Notification.permission === \"granted\") {\n      backgroundLog(\"üìú üîî Notification permission already granted\");\n      return true;\n    }\n\n    if (Notification.permission === \"denied\") {\n      backgroundLog(\"üìú üîî Notification permission previously denied\");\n      return false;\n    }\n\n    // Request notification permission\n    const permission = await Notification.requestPermission();\n\n    if (permission === \"granted\") {\n      backgroundLog(\n        \"üìú üîî ‚úÖ Notification permission granted - should help with anti-throttling\",\n      );\n\n      // Show a brief notification to confirm it works\n      new Notification(\"EngageKit\", {\n        body: \"Notification permission granted for better performance\",\n        icon: \"https://static.licdn.com/sc/h/3m6veb8kxx0k7v4c6u7q6z8hm\",\n        silent: true,\n      });\n\n      return true;\n    } else {\n      backgroundLog(\"üìú üîî ‚ùå Notification permission denied\");\n      return false;\n    }\n  } catch (error) {\n    backgroundWarn(\n      \"üìú üîî ‚ö†Ô∏è Failed to request notification permission:\",\n      error,\n    );\n    return false;\n  }\n}\n\n// Helper function to force LinkedIn to think tab is active\nasync function forceTabActiveState() {\n  try {\n    // Step 1: Request notification permission for anti-throttling\n    await requestNotificationPermissionForAntiThrottling();\n\n    // Step 2: Override document.hidden and document.visibilityState\n    Object.defineProperty(document, \"hidden\", {\n      value: false,\n      writable: false,\n    });\n\n    Object.defineProperty(document, \"visibilityState\", {\n      value: \"visible\",\n      writable: false,\n    });\n\n    // Step 3: Override document.hasFocus to return true\n    const originalHasFocus = document.hasFocus;\n    document.hasFocus = function () {\n      return true;\n    };\n\n    // Step 4: Prevent visibility change events\n    const originalAddEventListener = document.addEventListener;\n    document.addEventListener = function (\n      type: string,\n      listener: EventListenerOrEventListenerObject | null,\n      options?: boolean | AddEventListenerOptions,\n    ) {\n      if (type === \"visibilitychange\") {\n        // Don't add visibility change listeners\n        return;\n      }\n      if (listener === null) {\n        return;\n      }\n      return originalAddEventListener.call(this, type, listener, options);\n    };\n\n    backgroundLog(\"üìú üé≠ Applied comprehensive tab active state spoofing\");\n  } catch (error) {\n    backgroundWarn(\"üìú ‚ö†Ô∏è Failed to apply tab active state spoofing:\", error);\n  }\n}\n\n// Helper function to manually trigger LinkedIn's content loading\nfunction forceTriggerLinkedInLoading() {\n  try {\n    // Trigger visibility change event to \"visible\"\n    const visibilityEvent = new Event(\"visibilitychange\", { bubbles: true });\n    document.dispatchEvent(visibilityEvent);\n\n    // Trigger focus events\n    const focusEvent = new Event(\"focus\", { bubbles: true });\n    window.dispatchEvent(focusEvent);\n    document.dispatchEvent(focusEvent);\n\n    // Trigger page show event\n    const pageShowEvent = new PageTransitionEvent(\"pageshow\", {\n      bubbles: true,\n      persisted: false,\n    });\n    window.dispatchEvent(pageShowEvent);\n\n    // PRIORITY: Click LinkedIn's infinite scroll load button\n    const infiniteScrollButton = document.querySelector(\n      \".scaffold-finite-scroll__load-button\",\n    ) as HTMLButtonElement;\n    if (infiniteScrollButton && !infiniteScrollButton.disabled) {\n      infiniteScrollButton.click();\n      backgroundLog(\n        \"üìú üéØ Clicked LinkedIn infinite scroll load button (.scaffold-finite-scroll__load-button)\",\n      );\n    } else if (infiniteScrollButton && infiniteScrollButton.disabled) {\n      backgroundLog(\"üìú ‚ö†Ô∏è Infinite scroll button found but disabled\");\n    } else {\n      backgroundLog(\n        \"üìú ‚ÑπÔ∏è No infinite scroll button found (.scaffold-finite-scroll__load-button)\",\n      );\n    }\n  } catch (error) {\n    backgroundWarn(\"üìú ‚ö†Ô∏è Failed to trigger LinkedIn loading:\", error);\n  }\n}\n\n// Helper function to manually trigger scroll events for better LinkedIn compatibility\nfunction triggerScrollEvents() {\n  try {\n    // Create scroll event (following the 10-year-old solution approach)\n    const scrollEvent = new Event(\"scroll\", {\n      bubbles: true,\n      cancelable: true,\n    });\n\n    // Method 1: Traditional window/document events\n    window.dispatchEvent(scrollEvent);\n    document.dispatchEvent(scrollEvent);\n\n    // Method 2: Target LinkedIn's specific feed containers (key insight from old solution)\n    const linkedInFeedSelectors = [\n      \".scaffold-layout__main\", // Main content area\n      \".feed-container-theme\", // Feed container\n      \".scaffold-finite-scroll\", // Infinite scroll container\n      \".feed-shared-update-v2\", // Individual post containers\n      \".application-outlet\", // Main app container\n      \".feed-outlet\", // Feed outlet\n      \"#main\", // Main element\n      '[role=\"main\"]', // ARIA main role\n      \".ember-application\", // Ember app container\n    ];\n\n    // Dispatch scroll events to each LinkedIn container we can find\n    linkedInFeedSelectors.forEach((selector) => {\n      const elements = document.querySelectorAll(selector);\n      elements.forEach((element) => {\n        if (element) {\n          element.dispatchEvent(scrollEvent);\n          backgroundLog(`üìú üéØ Triggered scroll event on: ${selector}`);\n        }\n      });\n    });\n\n    // Method 3: Also trigger wheel events (some sites listen for these)\n    const wheelEvent = new WheelEvent(\"wheel\", {\n      bubbles: true,\n      cancelable: true,\n      deltaY: 100,\n      deltaMode: WheelEvent.DOM_DELTA_PIXEL,\n    });\n    window.dispatchEvent(wheelEvent);\n\n    // Trigger wheel events on main containers too\n    const mainContainer = document.querySelector(\n      \".scaffold-layout__main, .feed-container-theme\",\n    );\n    if (mainContainer) {\n      mainContainer.dispatchEvent(wheelEvent);\n      backgroundLog(\"üìú üéØ Triggered wheel event on main LinkedIn container\");\n    }\n  } catch (error) {\n    backgroundWarn(\"üìú ‚ö†Ô∏è Failed to trigger scroll events:\", error);\n  }\n}\n\n// Function to scroll feed and load posts - Aggressive scrolling to bottom\nasync function scrollFeedToLoadPosts(\n  duration: number,\n  statusPanel?: HTMLDivElement,\n): Promise<void> {\n  console.log(\n    `Aggressively scrolling feed for ${duration} seconds to load posts...`,\n  );\n  backgroundLog(\n    `üìú Starting aggressive scroll-to-bottom for ${duration} seconds...`,\n  );\n\n  // Apply tab active state spoofing immediately\n  await forceTabActiveState();\n\n  const startTime = Date.now();\n  const endTime = startTime + duration * 1000;\n\n  // Track metrics for debugging\n  let scrollAttempts = 0;\n  let postCountBefore = 0;\n  let lastPostCount = 0;\n\n  // Get initial post count\n  const initialPosts = document.querySelectorAll(\n    \".feed-shared-update-v2__control-menu-container\",\n  );\n  postCountBefore = initialPosts.length;\n  lastPostCount = postCountBefore;\n  backgroundLog(`üìú Initial post count: ${postCountBefore}`);\n\n  // Use aggressive scrolling - just go to bottom repeatedly\n  const pauseBetweenScrolls = 2000; // 2 second pause to allow content loading\n\n  while (Date.now() < endTime && isCommentingActive) {\n    // Check if we should stop\n    if (!isCommentingActive) {\n      backgroundLog(\"‚ùå Stopping scroll due to stop signal\");\n      break;\n    }\n\n    const currentTime = Date.now();\n    const timeRemaining = Math.round((endTime - currentTime) / 1000);\n    backgroundLog(\n      `üìú Aggressive scroll attempt ${\n        scrollAttempts + 1\n      }, ${timeRemaining}s remaining`,\n    );\n\n    // Update status panel if available\n    if (statusPanel) {\n      const currentPosts = document.querySelectorAll(\n        \".feed-shared-update-v2__control-menu-container\",\n      ).length;\n      const newPostsThisSession = currentPosts - postCountBefore;\n\n      const timeRemainingElement = statusPanel.querySelector(\n        \"#time-remaining span\",\n      );\n      const postsLoadedElement =\n        statusPanel.querySelector(\"#posts-loaded span\");\n      const scrollProgressElement = statusPanel.querySelector(\n        \"#scroll-progress span\",\n      );\n\n      if (timeRemainingElement) {\n        timeRemainingElement.textContent = `${timeRemaining}s`;\n      }\n\n      if (postsLoadedElement) {\n        postsLoadedElement.textContent = `${currentPosts} posts (+${newPostsThisSession} this session)`;\n      }\n\n      if (scrollProgressElement) {\n        scrollProgressElement.textContent = `Scroll attempt ${\n          scrollAttempts + 1\n        } - Loading content...`;\n      }\n    }\n\n    scrollAttempts++;\n\n    // Record current scroll position\n    const beforeScroll = window.scrollY;\n    const documentHeight = document.body.scrollHeight;\n\n    // Aggressive scroll: Go straight to bottom\n    window.scrollTo({ top: documentHeight, behavior: \"smooth\" });\n\n    // Trigger scroll events on LinkedIn's specific containers\n    triggerScrollEvents();\n\n    // Wait for scroll to complete and content to load\n    await wait(pauseBetweenScrolls);\n\n    const afterScroll = window.scrollY;\n    const newDocumentHeight = document.body.scrollHeight;\n\n    backgroundLog(\n      `üìú Scrolled from ${beforeScroll} to ${afterScroll}, doc height: ${documentHeight} ‚Üí ${newDocumentHeight}`,\n    );\n\n    // Check for new content after each scroll\n    const currentPosts = document.querySelectorAll(\n      \".feed-shared-update-v2__control-menu-container\",\n    );\n    const newPostCount = currentPosts.length;\n\n    if (newPostCount > lastPostCount) {\n      const newPosts = newPostCount - lastPostCount;\n      backgroundLog(\n        `üìú ‚úÖ Content loaded! Found ${newPosts} new posts (total: ${newPostCount})`,\n      );\n      lastPostCount = newPostCount;\n\n      // Update status panel with success indicator\n      if (statusPanel) {\n        const scrollProgressElement = statusPanel.querySelector(\n          \"#scroll-progress span\",\n        );\n        if (scrollProgressElement) {\n          scrollProgressElement.textContent = `‚úÖ Loaded ${newPosts} new posts! (Total: ${newPostCount})`;\n        }\n      }\n    } else {\n      backgroundLog(\n        `üìú ‚ö†Ô∏è No new posts detected. Still at ${newPostCount} posts`,\n      );\n\n      // Update status panel with no new content indicator\n      if (statusPanel) {\n        const scrollProgressElement = statusPanel.querySelector(\n          \"#scroll-progress span\",\n        );\n        if (scrollProgressElement) {\n          scrollProgressElement.textContent = `‚è≥ Waiting for new content... (${newPostCount} posts)`;\n        }\n      }\n    }\n\n    // Apply anti-throttling techniques periodically\n    if (scrollAttempts % 3 === 0) {\n      await forceTabActiveState();\n      forceTriggerLinkedInLoading();\n      backgroundLog(`üìú üé≠ Reapplied anti-throttling techniques`);\n\n      // Update status panel with anti-throttling indicator\n      if (statusPanel) {\n        const scrollProgressElement = statusPanel.querySelector(\n          \"#scroll-progress span\",\n        );\n        if (scrollProgressElement) {\n          scrollProgressElement.textContent = `üé≠ Applied anti-throttling techniques`;\n        }\n      }\n    }\n\n    // If document height didn't change, we might be done\n    if (\n      newDocumentHeight === documentHeight &&\n      newPostCount === lastPostCount\n    ) {\n      backgroundLog(\n        `üìú üìä No height or post changes detected - continuing for full duration`,\n      );\n    }\n  }\n\n  // Final status update\n  if (statusPanel) {\n    const finalPosts = document.querySelectorAll(\n      \".feed-shared-update-v2__control-menu-container\",\n    );\n    const totalNewPosts = finalPosts.length - postCountBefore;\n\n    const timeRemainingElement = statusPanel.querySelector(\n      \"#time-remaining span\",\n    );\n    const scrollProgressElement = statusPanel.querySelector(\n      \"#scroll-progress span\",\n    );\n\n    if (timeRemainingElement) {\n      timeRemainingElement.textContent = `0s - COMPLETE!`;\n    }\n\n    if (scrollProgressElement) {\n      scrollProgressElement.textContent = `üéâ Scrolling complete! Loaded ${totalNewPosts} new posts`;\n    }\n  }\n\n  // Final metrics\n  const finalPosts = document.querySelectorAll(\n    \".feed-shared-update-v2__control-menu-container\",\n  );\n  const totalNewPosts = finalPosts.length - initialPosts.length;\n  const actualDuration = Math.round((Date.now() - startTime) / 1000);\n\n  console.log(\"Finished aggressive scrolling to load posts\");\n  backgroundLog(\n    `üìú Aggressive scroll completed! Duration: ${actualDuration}s, Scroll attempts: ${scrollAttempts}, New posts loaded: ${totalNewPosts} (${initialPosts.length} ‚Üí ${finalPosts.length})`,\n  );\n\n  // Alert if we didn't load many posts\n  if (totalNewPosts < 15 && actualDuration > 15) {\n    backgroundWarn(\n      `üìú ‚ö†Ô∏è Only loaded ${totalNewPosts} posts in ${actualDuration}s. LinkedIn might be throttling or has limited content.`,\n    );\n  } else if (totalNewPosts >= 20) {\n    backgroundLog(\n      `üìú üéâ Excellent! Loaded ${totalNewPosts} posts using aggressive scrolling.`,\n    );\n  }\n}\n\n// Function to process all posts on the feed\nasync function processAllPostsOnFeed(\n  commentDelay: number,\n  maxPosts: number,\n  duplicateWindow: number,\n): Promise<void> {\n  console.group(\"üéØ PROCESSING ALL POSTS - DETAILED DEBUG\");\n  backgroundGroup(\"üéØ PROCESSING ALL POSTS - DETAILED DEBUG\");\n  console.log(\n    `üéØ Starting to process posts on feed (max ${maxPosts} posts)...`,\n  );\n  backgroundLog(\n    `üéØ Starting to process posts on feed (max ${maxPosts} posts)...`,\n  );\n\n  // Find all post containers using the top-level div[data-id] structure\n  const postContainers = document.querySelectorAll(\"div[data-id]\");\n  console.log(\n    `üéØ Found ${postContainers.length} post containers with selector: div[data-id]`,\n  );\n  backgroundLog(\n    `üéØ Found ${postContainers.length} post containers with selector: div[data-id]`,\n  );\n\n  // Let's also try alternative selectors to see what we find\n  const altSelector1 = document.querySelectorAll(\".feed-shared-update-v2\");\n  const altSelector2 = document.querySelectorAll(\n    '[data-urn*=\"urn:li:activity\"]',\n  );\n  const altSelector3 = document.querySelectorAll(\n    \".feed-shared-update-v2__content\",\n  );\n\n  console.log(`üéØ Alternative selector results:`);\n  console.log(`   - .feed-shared-update-v2: ${altSelector1.length} elements`);\n  console.log(\n    `   - [data-urn*=\"urn:li:activity\"]: ${altSelector2.length} elements`,\n  );\n  console.log(\n    `   - .feed-shared-update-v2__content: ${altSelector3.length} elements`,\n  );\n  backgroundLog(\n    `üéØ Alternative selector results: .feed-shared-update-v2: ${altSelector1.length}, [data-urn*=\"urn:li:activity\"]: ${altSelector2.length}, .feed-shared-update-v2__content: ${altSelector3.length}`,\n  );\n\n  if (postContainers.length === 0) {\n    console.error(\n      \"üö® NO POSTS FOUND! This is why the automation stops immediately.\",\n    );\n    console.error(\n      \"üö® The page might not be fully loaded or the selector is wrong.\",\n    );\n    backgroundError(\n      \"üö® NO POSTS FOUND! This is why the automation stops immediately.\",\n    );\n    backgroundError(\n      \"üö® The page might not be fully loaded or the selector is wrong.\",\n    );\n    console.groupEnd();\n    backgroundGroupEnd();\n    return;\n  }\n\n  let commentCount = 0;\n  console.log(\n    `üéØ Starting loop: commentCount=${commentCount}, maxPosts=${maxPosts}, isActive=${isCommentingActive}`,\n  );\n  backgroundLog(\n    `üéØ Starting loop: commentCount=${commentCount}, maxPosts=${maxPosts}, isActive=${isCommentingActive}`,\n  );\n\n  for (\n    let i = 0;\n    i < postContainers.length && isCommentingActive && commentCount < maxPosts;\n    i++\n  ) {\n    console.group(\n      `üîÑ POST ${i + 1}/${postContainers.length} - DETAILED PROCESSING`,\n    );\n    console.log(`üîÑ Loop iteration ${i + 1}:`);\n    console.log(`   - commentCount: ${commentCount}/${maxPosts}`);\n    console.log(`   - isCommentingActive: ${isCommentingActive}`);\n    console.log(\n      `   - Loop condition: i(${i}) < postContainers.length(${\n        postContainers.length\n      }) = ${i < postContainers.length}`,\n    );\n    console.log(\n      `   - Active condition: isCommentingActive = ${isCommentingActive}`,\n    );\n    console.log(\n      `   - Count condition: commentCount(${commentCount}) < maxPosts(${maxPosts}) = ${\n        commentCount < maxPosts\n      }`,\n    );\n    console.log(\n      `   - Overall loop should continue: ${\n        i < postContainers.length &&\n        isCommentingActive &&\n        commentCount < maxPosts\n      }`,\n    );\n\n    // Check if we should stop at the beginning of each iteration\n    if (!isCommentingActive) {\n      console.log(\"‚ùå STOPPING: isCommentingActive became false\");\n      console.groupEnd();\n      break;\n    }\n\n    const postContainer = postContainers[i] as HTMLElement;\n\n    try {\n      console.log(\n        `üîç Processing post ${i + 1}/${\n          postContainers.length\n        } (commented: ${commentCount}/${maxPosts})`,\n      );\n\n      // Scroll to the post\n      postContainer.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n      await wait(1000);\n\n      // Check again after scroll\n      if (!isCommentingActive) {\n        console.log(\n          \"‚ùå STOPPING: isCommentingActive became false after scroll\",\n        );\n        console.groupEnd();\n        break;\n      }\n\n      // STEP 1: Check for post URN duplicates (if we've already commented on this specific post)\n      const postUrns = extractPostUrns(postContainer);\n      if (postUrns.length === 0) {\n        console.log(`‚è≠Ô∏è SKIPPING post ${i + 1} - could not extract post URNs`);\n        console.groupEnd();\n        continue;\n      }\n\n      // Check if we've commented on any of these URNs before\n      let hasCommentedOnThisPost = false;\n      for (const urn of postUrns) {\n        if (hasCommentedOnPostUrn(urn)) {\n          console.log(\n            `‚è≠Ô∏è SKIPPING post ${i + 1} - already commented on post URN: ${urn}`,\n          );\n          hasCommentedOnThisPost = true;\n          break;\n        }\n      }\n\n      if (hasCommentedOnThisPost) {\n        // Update the post already commented counter\n        await updatePostAlreadyCommentedCounter();\n        console.groupEnd();\n        continue;\n      }\n\n      // STEP 2: Check for author duplicate (within time window)\n      const authorInfo = extractAuthorInfo(postContainer);\n      if (!authorInfo) {\n        console.log(\n          `‚è≠Ô∏è SKIPPING post ${i + 1} - could not extract author info`,\n        );\n        console.groupEnd();\n        continue;\n      }\n\n      // Check if we've commented on this author within the time window\n      if (\n        hasCommentedOnAuthorRecently(\n          authorInfo.name,\n          commentedAuthorsWithTimestamps,\n          duplicateWindow,\n        )\n      ) {\n        console.log(\n          `‚è≠Ô∏è SKIPPING post ${i + 1} - already commented on ${\n            authorInfo.name\n          } within ${duplicateWindow} hours`,\n        );\n\n        // Update counters\n        await updateSkippedPostCounter();\n\n        console.groupEnd();\n        continue;\n      }\n\n      // Extract post content\n      const postContent = extractPostContent(postContainer);\n      if (!postContent) {\n        console.log(\n          `‚è≠Ô∏è SKIPPING post ${i + 1} - could not extract post content`,\n        );\n        console.groupEnd();\n        continue;\n      }\n\n      const postAuthorContent = authorInfo.name + postContent;\n\n      console.log(\n        `üìù Post content preview: ${postContent.substring(0, 100)}...`,\n      );\n\n      // Check again before generating comment\n      if (!isCommentingActive) {\n        console.log(\n          \"‚ùå STOPPING: isCommentingActive became false before comment generation\",\n        );\n        console.groupEnd();\n        break;\n      }\n\n      // Generate comment using background script\n      console.log(`ü§ñ Generating comment for post ${i + 1}...`);\n      const comment = await generateComment(postAuthorContent);\n      console.log(\n        `ü§ñ Comment generation result for post ${i + 1}:`,\n        comment ? \"SUCCESS\" : \"FAILED\",\n      );\n\n      if (!comment) {\n        console.log(`‚ùå SKIPPING post ${i + 1} - could not generate comment`);\n        console.groupEnd();\n        continue;\n      }\n\n      console.log(\n        `‚úÖ Generated comment for post ${i + 1}:`,\n        comment.substring(0, 50) + \"...\",\n      );\n\n      // Check again before posting comment\n      if (!isCommentingActive) {\n        console.log(\n          \"‚ùå STOPPING: isCommentingActive became false before posting comment\",\n        );\n        console.groupEnd();\n        break;\n      }\n\n      // Post the comment\n      console.log(\n        `üìù Attempting to post comment on post ${i + 1} by ${\n          authorInfo.name\n        }...`,\n      );\n      const success = await postCommentOnPost(postContainer, comment);\n      console.log(\n        `üìù Comment posting result for post ${i + 1}: ${\n          success ? \"SUCCESS\" : \"FAILED\"\n        }`,\n      );\n\n      if (success) {\n        commentCount++;\n        commentedAuthors.add(authorInfo.name);\n\n        // Save author with timestamp and update counts\n        await saveCommentedAuthor(authorInfo.name); // for backward compatibility\n        await saveCommentedAuthorWithTimestamp(authorInfo.name); // new timestamp-based storage\n        commentedAuthorsWithTimestamps.set(authorInfo.name, Date.now()); // update in-memory data\n\n        // Save all post URNs to prevent commenting on this post again\n        for (const urn of postUrns) {\n          await saveCommentedPostUrn(urn);\n        }\n\n        await updateCommentCounts();\n\n        console.log(\n          `üéâ Successfully posted comment ${commentCount}/${maxPosts} on post by ${authorInfo.name}`,\n        );\n        backgroundLog(\n          `üéâ Successfully posted comment ${commentCount}/${maxPosts} on post by ${authorInfo.name}`,\n        );\n        console.group(`üìä Progress Update After Successful Comment`);\n        console.log(\n          `Comments posted this session: ${commentCount}/${maxPosts}`,\n        );\n        console.log(\n          `Authors commented on today:`,\n          Array.from(commentedAuthors),\n        );\n        console.log(\n          `Remaining posts to process: ${postContainers.length - i - 1}`,\n        );\n        console.log(\n          `Should continue? commentCount(${commentCount}) < maxPosts(${maxPosts}) = ${\n            commentCount < maxPosts\n          }`,\n        );\n        console.log(\n          `Next iteration will be: ${i + 1} < ${postContainers.length} = ${\n            i + 1 < postContainers.length\n          }`,\n        );\n        backgroundLog(\n          `üìä Progress Update: ${commentCount}/${maxPosts} comments posted. Remaining posts: ${\n            postContainers.length - i - 1\n          }. Should continue: ${commentCount < maxPosts}`,\n        );\n        console.groupEnd();\n\n        // Update background script with progress\n        chrome.runtime.sendMessage({\n          action: \"updateCommentCount\",\n          count: commentCount,\n          status: `Posted comment ${commentCount}/${maxPosts} on post by ${authorInfo.name}`,\n        });\n\n        // Check if we've reached the max posts limit\n        if (commentCount >= maxPosts) {\n          console.log(\n            `‚úÖ REACHED MAX POSTS LIMIT: commentCount(${commentCount}) >= maxPosts(${maxPosts}). Stopping...`,\n          );\n          backgroundLog(\n            `‚úÖ REACHED MAX POSTS LIMIT: commentCount(${commentCount}) >= maxPosts(${maxPosts}). Stopping...`,\n          );\n          console.groupEnd();\n          break;\n        }\n\n        // Wait between comments with stop checking\n        if (i < postContainers.length - 1 && commentCount < maxPosts) {\n          console.log(\n            `‚è≥ Waiting ${commentDelay} seconds before next comment...`,\n          );\n          console.log(\n            `‚è≥ Delay conditions: i(${i}) < postContainers.length-1(${\n              postContainers.length - 1\n            }) = ${i < postContainers.length - 1}`,\n          );\n          console.log(\n            `‚è≥ Delay conditions: commentCount(${commentCount}) < maxPosts(${maxPosts}) = ${\n              commentCount < maxPosts\n            }`,\n          );\n\n          // Break the delay into smaller chunks to check for stop signal\n          const delayChunks = Math.ceil(commentDelay);\n          for (\n            let chunk = 0;\n            chunk < delayChunks && isCommentingActive;\n            chunk++\n          ) {\n            await wait(1000);\n            if (!isCommentingActive) {\n              console.log(\n                \"‚ùå STOPPING during comment delay due to stop signal\",\n              );\n              console.groupEnd();\n              break;\n            }\n          }\n\n          if (!isCommentingActive) {\n            console.groupEnd();\n            break;\n          }\n\n          console.log(`‚úÖ Delay completed, continuing to next post...`);\n        } else {\n          console.log(\n            `üîö No delay needed - this was the last post or we've reached max comments`,\n          );\n          console.log(\n            `   - i(${i}) < postContainers.length-1(${\n              postContainers.length - 1\n            }): ${i < postContainers.length - 1}`,\n          );\n          console.log(\n            `   - commentCount(${commentCount}) < maxPosts(${maxPosts}): ${\n              commentCount < maxPosts\n            }`,\n          );\n        }\n      } else {\n        console.log(\n          `‚ùå Failed to post comment on post ${i + 1} by ${authorInfo.name}`,\n        );\n      }\n\n      console.groupEnd();\n    } catch (error) {\n      console.error(`üí• Error processing post ${i + 1}:`, error);\n      console.groupEnd();\n    }\n\n    // Debug the next iteration conditions\n    console.log(`üîÑ End of iteration ${i + 1}. Next iteration check:`);\n    console.log(`   - Next i will be: ${i + 1}`);\n    console.log(`   - postContainers.length: ${postContainers.length}`);\n    console.log(`   - isCommentingActive: ${isCommentingActive}`);\n    console.log(`   - commentCount: ${commentCount}`);\n    console.log(`   - maxPosts: ${maxPosts}`);\n    console.log(\n      `   - Loop will continue: ${\n        i + 1 < postContainers.length &&\n        isCommentingActive &&\n        commentCount < maxPosts\n      }`,\n    );\n  }\n\n  console.log(`üèÅ LOOP COMPLETED. Final stats:`);\n  console.log(`   - Posted ${commentCount}/${maxPosts} comments total`);\n  console.log(`   - Final isCommentingActive: ${isCommentingActive}`);\n  console.log(`   - Processed ${postContainers.length} total posts`);\n  console.log(`   - Loop exit reason analysis:`);\n  console.log(`     - Reached max posts? ${commentCount >= maxPosts}`);\n  console.log(`     - Lost active status? ${!isCommentingActive}`);\n  console.log(`     - Ran out of posts? ${postContainers.length === 0}`);\n  backgroundLog(\n    `üèÅ LOOP COMPLETED. Final stats: Posted ${commentCount}/${maxPosts} comments total. Final isCommentingActive: ${isCommentingActive}. Processed ${postContainers.length} total posts.`,\n  );\n  backgroundLog(\n    `üèÅ Loop exit reason: Reached max posts? ${\n      commentCount >= maxPosts\n    }, Lost active status? ${!isCommentingActive}, Ran out of posts? ${\n      postContainers.length === 0\n    }`,\n  );\n  console.groupEnd();\n  backgroundGroupEnd();\n}\n\n// Function to parse time strings like \"15h\", \"5m\", \"2d\" into hours\nfunction parseTimeStringToHours(timeStr: string): number | null {\n  if (!timeStr || typeof timeStr !== \"string\") {\n    return null;\n  }\n\n  // Remove any extra whitespace and convert to lowercase\n  const cleaned = timeStr.trim().toLowerCase();\n\n  // Handle \"Promoted\" posts\n  if (cleaned === \"promoted\" || cleaned.includes(\"promoted\")) {\n    return null;\n  }\n\n  // Extract number and unit using regex\n  const match = cleaned.match(/^(\\d+)([mhdw])$/);\n  if (!match) {\n    console.log(`Could not parse time string: \"${timeStr}\"`);\n    return null;\n  }\n\n  const [, numberStr, unit] = match;\n  const number = parseInt(numberStr, 10);\n\n  if (isNaN(number)) {\n    return null;\n  }\n\n  // Convert to hours\n  switch (unit) {\n    case \"m\": // minutes\n      return number / 60;\n    case \"h\": // hours\n      return number;\n    case \"d\": // days\n      return number * 24;\n    case \"w\": // weeks\n      return number * 24 * 7;\n    default:\n      return null;\n  }\n}\n\n// Function to extract post time from post container\nfunction extractPostTime(postContainer: HTMLElement): number | null {\n  try {\n    // Look for the time span with the specific classes\n    const timeSpan = postContainer.querySelector(\n      \".update-components-actor__sub-description.text-body-xsmall\",\n    );\n\n    if (!timeSpan || !timeSpan.textContent) {\n      console.log(\"Time span not found or has no text content\");\n      return null;\n    }\n\n    const timeText = timeSpan.textContent.trim();\n    console.log(`Found time text: \"${timeText}\"`);\n\n    return parseTimeStringToHours(timeText);\n  } catch (error) {\n    console.error(\"Error extracting post time:\", error);\n    return null;\n  }\n}\n\n// Function to update time filter skipped counter\nasync function updateTimeFilterSkippedCounter(): Promise<void> {\n  postsSkippedTimeFilterCount++;\n\n  return new Promise((resolve) => {\n    chrome.storage.local.set(\n      {\n        postsSkippedTimeFilter: postsSkippedTimeFilterCount,\n      },\n      () => {\n        console.log(\n          `Updated time filter skipped counter: ${postsSkippedTimeFilterCount}`,\n        );\n\n        // Send real-time update to popup\n        chrome.runtime.sendMessage({\n          action: \"realTimeCountUpdate\",\n          postsSkippedTimeFilterCount: postsSkippedTimeFilterCount,\n        });\n\n        resolve();\n      },\n    );\n  });\n}\n\n// Function to extract author info from post container\nfunction extractAuthorInfo(\n  postContainer: HTMLElement,\n): { name: string } | null {\n  try {\n    // Look for author container within the post\n    const authorContainer = postContainer.querySelector(\n      \".update-components-actor__container\",\n    );\n    if (!authorContainer) {\n      console.log(\"Author container not found\");\n      return null;\n    }\n\n    // Try different selectors for author name\n    const nameSelectors = [\n      '.update-components-actor__title span[dir=\"ltr\"] span[aria-hidden=\"true\"]',\n      '.update-components-actor__title span[aria-hidden=\"true\"]',\n      \".update-components-actor__title\",\n      \".update-components-actor__name\",\n    ];\n\n    for (const selector of nameSelectors) {\n      const nameElement = authorContainer.querySelector(selector);\n      if (nameElement && nameElement.textContent) {\n        const name = nameElement.textContent\n          .replace(/<!---->/g, \"\")\n          .trim()\n          .split(\"‚Ä¢\")[0]\n          .trim();\n        if (name) {\n          console.log(`Extracted author name: ${name}`);\n          return { name };\n        }\n      }\n    }\n\n    console.log(\"Could not extract author name\");\n    return null;\n  } catch (error) {\n    console.error(\"Error extracting author info:\", error);\n    return null;\n  }\n}\n\n// Function to extract post content from post container\nfunction extractPostContent(postContainer: HTMLElement): string {\n  try {\n    // Look for the content container within the post\n    // const contentContainer = postContainer.querySelector('.fie-impression-container');\n    const contentContainer = postContainer.querySelector(\n      \".feed-shared-inline-show-more-text\",\n    );\n    if (!contentContainer) {\n      console.log(\"Content container not found\");\n      return \"\";\n    }\n\n    // Extract text content recursively\n    function extractText(node: Node): string {\n      let text = \"\";\n      node.childNodes.forEach((child) => {\n        if (child.nodeType === Node.TEXT_NODE) {\n          text += child.textContent?.trim() + \" \";\n        } else if (child.nodeType === Node.ELEMENT_NODE) {\n          text += extractText(child);\n        }\n      });\n      return text;\n    }\n\n    const content = extractText(contentContainer).replace(/\\s+/g, \" \").trim();\n    console.log(`Extracted post content: ${content.substring(0, 100)}...`);\n    return content;\n  } catch (error) {\n    console.error(\"Error extracting post content:\", error);\n    return \"\";\n  }\n}\n\n// Function to generate comment using background script\nasync function generateComment(postContent: string): Promise<string> {\n  return new Promise((resolve) => {\n    console.log(\n      \"ü§ñ Requesting comment generation for post content:\",\n      postContent.substring(0, 200) + \"...\",\n    );\n\n    // Set up a 30-second timeout\n    const timeout = setTimeout(() => {\n      console.error(\n        \"‚è∞ FALLBACK REASON: Comment generation timed out after 30 seconds\",\n      );\n      console.error(\n        \"‚è∞ TIMEOUT - No response from background script within 30 seconds\",\n      );\n      resolve(\"Great post! Thanks for sharing.\");\n    }, 30000);\n\n    // Retry mechanism for connection issues\n    const attemptGeneration = (attempt: number = 1): void => {\n      console.log(\n        `üîÑ Attempt ${attempt}/3: Sending comment generation request...`,\n      );\n\n      chrome.runtime.sendMessage(\n        {\n          action: \"generateComment\",\n          postContent: postContent,\n        },\n        (response) => {\n          clearTimeout(timeout); // Clear the timeout since we got a response\n\n          if (chrome.runtime.lastError) {\n            console.error(\n              `üí• ATTEMPT ${attempt} FAILED - Chrome runtime error:`,\n              chrome.runtime.lastError,\n            );\n\n            // Check if it's a connection error and retry\n            if (\n              chrome.runtime.lastError.message?.includes(\n                \"Could not establish connection\",\n              ) &&\n              attempt < 3\n            ) {\n              console.log(\n                `üîÑ Connection error detected, retrying in 2 seconds... (attempt ${\n                  attempt + 1\n                }/3)`,\n              );\n              setTimeout(() => {\n                attemptGeneration(attempt + 1);\n              }, 2000);\n              return;\n            }\n\n            console.error(\n              \"üí• FALLBACK REASON: Chrome runtime error during comment generation\",\n            );\n            console.error(\"üí• CHROME ERROR:\", chrome.runtime.lastError);\n            console.error(\n              \"üí• This usually means the background script crashed or message passing failed\",\n            );\n            resolve(\"Great post! Thanks for sharing.\");\n          } else if (!response) {\n            console.error(\n              `‚ùå ATTEMPT ${attempt} FAILED - No response received from background script`,\n            );\n\n            // Retry if no response\n            if (attempt < 3) {\n              console.log(\n                `üîÑ No response received, retrying in 2 seconds... (attempt ${\n                  attempt + 1\n                }/3)`,\n              );\n              setTimeout(() => {\n                attemptGeneration(attempt + 1);\n              }, 2000);\n              return;\n            }\n\n            console.error(\n              \"‚ùå FALLBACK REASON: No response received from background script after 3 attempts\",\n            );\n            console.error(\n              \"‚ùå RESPONSE NULL - Background script may have failed silently\",\n            );\n            resolve(\"Great post! Thanks for sharing.\");\n          } else if (!response.comment) {\n            console.error(\n              \"‚ö†Ô∏è FALLBACK REASON: Response received but no comment field\",\n            );\n            console.error(\"‚ö†Ô∏è INVALID RESPONSE STRUCTURE:\", response);\n            console.error(\n              \"‚ö†Ô∏è Expected response.comment but got:\",\n              Object.keys(response),\n            );\n            resolve(\"Great post! Thanks for sharing.\");\n          } else if (response.comment === \"Great post! Thanks for sharing.\") {\n            console.error(\n              \"üö® FALLBACK REASON: Background script returned the default fallback comment\",\n            );\n            console.error(\n              \"üö® This means the AI API failed and background script used fallback\",\n            );\n\n            // Check if error details were provided in the response\n            if (response.error) {\n              console.group(\"üî• AI API ERROR DETAILS FROM RESPONSE\");\n              console.error(\"üî• Error Message:\", response.error.message);\n              console.error(\"üî• Error Type:\", response.error.name);\n              console.error(\"üî• API Key Status:\", response.error.apiKey);\n              console.error(\n                \"üî• Style Guide Status:\",\n                response.error.styleGuide,\n              );\n              console.error(\n                \"üî• Post Content Length:\",\n                response.error.postContentLength,\n                \"characters\",\n              );\n              if (response.error.stack) {\n                console.error(\"üî• Stack Trace:\", response.error.stack);\n              }\n              console.groupEnd();\n            } else {\n              console.error(\n                \"üö® No error details provided - check background script console\",\n              );\n            }\n\n            resolve(response.comment);\n          } else {\n            console.log(\n              \"‚úÖ Successfully received generated comment:\",\n              response.comment.substring(0, 100) + \"...\",\n            );\n            resolve(response.comment);\n          }\n        },\n      );\n    };\n\n    // Start the first attempt\n    attemptGeneration(1);\n  });\n}\n\n// Function to post comment on a specific post\nasync function postCommentOnPost(\n  postContainer: HTMLElement,\n  comment: string,\n): Promise<boolean> {\n  try {\n    console.group(\"üìù Comment Posting Process\");\n    console.log(\"Starting to post comment:\", comment.substring(0, 100) + \"...\");\n\n    // Check if we should stop before starting\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping comment posting due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 1: Find and click the comment button\n    console.log(\"üîç Looking for comment button...\");\n    const commentButton = postContainer.querySelector(\n      'button[aria-label=\"Comment\"]',\n    ) as HTMLButtonElement;\n    if (!commentButton) {\n      console.error(\"‚ùå Comment button not found\");\n      console.groupEnd();\n      return false;\n    }\n\n    console.log(\"üëÜ Clicking comment button...\");\n    commentButton.click();\n\n    // Wait for comment editor to appear\n    console.log(\"‚è≥ Waiting for comment editor to appear...\");\n    await wait(2000);\n\n    // Check again after wait\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping during comment editor wait due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 2: Find the comment editor\n    console.log(\"üîç Looking for comment editor...\");\n    const commentEditor = postContainer.querySelector(\n      \".comments-comment-box-comment__text-editor\",\n    );\n    if (!commentEditor) {\n      console.error(\"‚ùå Comment editor not found\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 3: Find the editable field within the editor\n    console.log(\"üîç Looking for editable field...\");\n    const editableField = commentEditor.querySelector(\n      'div[contenteditable=\"true\"]',\n    ) as HTMLElement;\n    if (!editableField) {\n      console.error(\"‚ùå Editable field not found\");\n      console.groupEnd();\n      return false;\n    }\n\n    console.log(\"‚úÖ Found editable field, inputting comment...\");\n\n    // Check again before inputting\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping during comment input due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 4: Click on the editable field and input the comment\n    editableField.focus();\n    editableField.click();\n    editableField.innerHTML = \"\";\n\n    // Input the comment text\n    const lines = comment.split(\"\\n\");\n    lines.forEach((lineText) => {\n      const p = document.createElement(\"p\");\n      if (lineText === \"\") {\n        p.appendChild(document.createElement(\"br\"));\n      } else {\n        p.textContent = lineText;\n      }\n      editableField.appendChild(p);\n    });\n\n    // Set cursor position and trigger input event\n    const selection = window.getSelection();\n    if (selection) {\n      const range = document.createRange();\n      if (editableField.lastChild) {\n        range.setStartAfter(editableField.lastChild);\n      } else {\n        range.selectNodeContents(editableField);\n      }\n      range.collapse(true);\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    editableField.focus();\n\n    const inputEvent = new Event(\"input\", { bubbles: true, cancelable: true });\n    editableField.dispatchEvent(inputEvent);\n\n    console.log(\"‚úÖ Comment text inputted successfully\");\n\n    // Wait for submit button to become enabled\n    console.log(\"‚è≥ Waiting for submit button to become enabled...\");\n    await wait(1000);\n\n    // Check again before submitting\n    if (!isCommentingActive) {\n      console.log(\"‚ùå Stopping during submit button wait due to stop signal\");\n      console.groupEnd();\n      return false;\n    }\n\n    // Step 5: Find and click the submit button\n    console.log(\"üîç Looking for submit button...\");\n    const submitButton = postContainer.querySelector(\n      \".comments-comment-box__submit-button--cr\",\n    ) as HTMLButtonElement;\n    if (!submitButton || submitButton.disabled) {\n      console.error(\"‚ùå Submit button not found or disabled\");\n      console.groupEnd();\n      return false;\n    }\n\n    console.log(\"üöÄ Clicking submit button...\");\n    submitButton.click();\n\n    // Wait for comment to be posted\n    console.log(\"‚è≥ Waiting for comment to be posted...\");\n    await wait(2000);\n\n    console.log(\"üéâ Comment posted successfully\");\n    console.groupEnd();\n    return true;\n  } catch (error) {\n    console.error(\"üí• Error posting comment:\", error);\n    console.groupEnd();\n    return false;\n  }\n}\n\n// Function to clean up old timestamp entries (older than 7 days)\nasync function cleanupOldTimestamps(): Promise<void> {\n  const storageKey = \"commented_authors_timestamps\";\n  const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;\n  const now = Date.now();\n\n  return new Promise((resolve) => {\n    chrome.storage.local.get([storageKey], (result) => {\n      const authorTimestamps = result[storageKey] || {};\n      const cleanedTimestamps: { [key: string]: number } = {};\n\n      let removedCount = 0;\n      for (const [authorName, timestamp] of Object.entries(authorTimestamps)) {\n        if (typeof timestamp === \"number\" && now - timestamp < sevenDaysInMs) {\n          cleanedTimestamps[authorName] = timestamp;\n        } else {\n          removedCount++;\n        }\n      }\n\n      if (removedCount > 0) {\n        chrome.storage.local.set({ [storageKey]: cleanedTimestamps }, () => {\n          console.log(`Cleaned up ${removedCount} old timestamp entries`);\n          resolve();\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nconsole.log(\"EngageKit content script loaded - Background Window Mode\");\n"],"names":["AudioThrottleService","__publicField","resolve","reject","AudioContext","oscillator","gainNode","mediaStreamDestination","minFreq","maxFreq","frequency","playPromise","error","audioService","request","sender","sendResponse"],"mappings":"oKAAO,MAAMA,CAAqB,CAA3B,cACGC,EAAA,oBAAoC,MACpCA,EAAA,yBAA2C,MAC3CA,EAAA,oBAAwC,MAEzC,OAAuB,CAC5B,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,GAAI,CACF,QAAQ,IAAI,uDAAuD,EAGnE,MAAMC,EACJ,OAAO,cAAiB,OAAe,mBAGzC,GAAI,CAACA,EACH,MAAM,IAAI,MACR,oEAAA,EAMJ,KAAK,aAAe,IAAIA,EAKxB,MAAMC,EAAa,KAAK,aAAa,iBAAA,EAG/BC,EAAW,KAAK,aAAa,WAAA,EAI7BC,EACJ,KAAK,aAAa,6BAAA,EAKpBF,EAAW,QAAQC,CAAQ,EAC3BA,EAAS,QAAQC,CAAsB,EAOvCF,EAAW,KAAO,OAKlB,MAAMG,EAAU,OACVC,EAAU,OAEVC,EAAY,IAGlBL,EAAW,UAAU,eACnBK,EACA,KAAK,aAAa,WAAA,EAKpBJ,EAAS,KAAK,eAAe,KAAO,KAAK,aAAa,WAAW,EAKjE,KAAK,aAAe,SAAS,cAAc,OAAO,EAGlD,KAAK,aAAa,UAAYC,EAAuB,OAIrD,KAAK,aAAa,SAAW,GAG7B,KAAK,aAAa,KAAO,GAGzB,KAAK,aAAa,SAAW,GAG7B,KAAK,aAAa,MAAM,QACtB,6CAMF,SAAS,KAAK,YAAY,KAAK,YAAY,GAGhB,SAAY,CACjC,KAAK,aAAc,QAAU,aAC/B,MAAM,KAAK,aAAc,OAAA,EAK3BF,EAAW,MAAA,EACX,KAAK,kBAAoBA,EAIzB,MAAMM,EAAc,KAAK,aAAc,KAAA,EAEnCA,IAAgB,OAClBA,EACG,KAAK,IAAM,CAEV,QAAQ,IACN,eAAeN,EAAW,IAAI,YAAYK,EAAU,QAClD,CAAA,CACD,0CAAA,EAEHR,EAAA,CAAQ,CACT,EACA,MAAOU,GAAU,CAEhB,QAAQ,KACN,2CACAA,CAAA,EAEFT,EAAOS,CAAK,CAAA,CACb,GAEH,QAAQ,IAAI,oDAAoD,EAChEV,EAAA,EACF,GAGF,CAAmB,OACZU,EAAO,CACd,QAAQ,MAAM,wBAAyBA,CAAK,EAC5CT,EAAOS,CAAK,CAAA,CACd,CACD,CAAA,CAGI,MAAa,CAClB,GAAI,CACF,QAAQ,IAAI,iCAAiC,EAEzC,KAAK,oBACP,KAAK,kBAAkB,KAAA,EACvB,KAAK,kBAAoB,MAGvB,KAAK,eACP,KAAK,aAAa,MAAA,EAClB,KAAK,aAAa,OAAA,EAClB,KAAK,aAAe,MAGlB,KAAK,cAAgB,KAAK,aAAa,QAAU,WACnD,KAAK,aAAa,MAAA,EAClB,KAAK,aAAe,MAGtB,QAAQ,IAAI,6BAA6B,CAAA,OAClCA,EAAO,CACd,QAAQ,KAAK,2BAA4BA,CAAK,CAAA,CAChD,CAEJ,CCpJA,MAAMC,EAAe,IAAIb,EAMrB,SAAS,aAAe,WAC1B,QAAQ,IAAI,mDAAmD,EAE/D,OAAO,QAAQ,YAAY,CACzB,OAAQ,WAAA,CACT,GAED,SAAS,iBAAiB,mBAAoB,UAAY,CACxD,QAAQ,IAAI,yCAAyC,EAErD,OAAO,QAAQ,YAAY,CACzB,OAAQ,WAAA,CACT,CAAA,CACF,EAyRH,OAAO,QAAQ,UAAU,YAAY,CAACc,EAASC,EAAQC,IAAiB,CAClEF,EAAQ,SAAW,uBACrB,QAAQ,IAAI,kDAAkD,EAE9DE,EAAa,CAAE,QAAS,GAAM,GACrBF,EAAQ,SAAW,sBAC5B,QAAQ,IAAI,iDAAiD,EAE7DD,EAAa,KAAA,EACbG,EAAa,CAAE,QAAS,GAAM,GACrBF,EAAQ,MAIrB,CAAC,EAgzDD,QAAQ,IAAI,0DAA0D"}